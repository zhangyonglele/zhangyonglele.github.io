<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>prime-for-rsa</title>
      <link href="/2020/12/17/prime-for-rsa/"/>
      <url>/2020/12/17/prime-for-rsa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中Cipher加密模块的使用方法分析</title>
      <link href="/2020/12/13/java-cipher/"/>
      <url>/2020/12/13/java-cipher/</url>
      
        <content type="html"><![CDATA[<p>有关于Java中加密算法的应用有很多，比如AES、md5，RSA等，大多数密码使用需要Cipher来进行辅助。</p><a id="more"></a><h3><span id="初始化cipher的参数内涵和基本原理">初始化Cipher的参数内涵和基本原理</span></h3><p>在使用Cihper对其进行初始化的时候，在调用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cipher.getInstance(String transformation);</span><br></pre></td></tr></table></figure></p><p>对于其中字符串参数 <em>transformation</em> （即转换模式）进行分析，其作用实际上是两种。</p><p>查阅一下文档（基于JDK11）：</p><blockquote><p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/Cipher.html" target="_blank" rel="noopener">sun基于JDK11的Cipher官方文档</a></p></blockquote><p>在描述中，我们可以发现对该参数的描述如下：</p><blockquote><p>A transformation is a string that describes the operation (or set of operations) to be performed on the given input, to produce some output. A transformation always includes the name of a cryptographic algorithm (e.g., AES), and may be followed by a feedback mode and padding scheme.</p><p>A transformation is of the form:</p><ul><li><p><em>“algorithm/mode/padding”</em> or</p></li><li><p><em>“algorithm”</em></p></li></ul><p>(in the latter case, provider-specific default values for the mode and padding scheme are used). For example, the following is a valid transformation:</p><pre><code>Cipher c = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);</code></pre></blockquote><p>在文章中看到该参数具有两种使用方法，一种是传统的直接将算法名称输入到Cipher初始化方法中，是最简单的，还有另一种是 <em>算法/工作模式/填充模式</em> 的较为完整的参数传递。</p><h4><span id="算法">算法</span></h4><p>算法就是我们常说的 AES, RSA等算法，不在此处详细描述。</p><h4><span id="工作模式">工作模式</span></h4><p>工作模式指的是在分组密码的实践中，将密码划分为长度为n的组。</p><h4><span id="填充模式">填充模式</span></h4><p>padding一般是指在原文长度当大于一个块的长度时，使用某种填充方式将空闲下来的长度（即不满一块的部分）使用某种规则填充</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Cipher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webflux初窥</title>
      <link href="/2020/10/27/webflux/"/>
      <url>/2020/10/27/webflux/</url>
      
        <content type="html"><![CDATA[<p>在初探Webflux之前，要先理解什么是Webflux技术。</p><h3><span id="servlet运行模式">Servlet运行模式</span></h3><p>在Webflux技术出现之前，服务器的响应模式是由Servlet+容器（如Tomcat）组成的，服务器响应模式是同步阻塞的。在Spring的框架下重新组建的servlet规范依旧是同步阻塞的模式，他们运行在在servlet容器中。</p><p>这种Servlet的运行模式是基于大型线程池+新建线程的模式。当请求进入后，为了防止线程阻塞，容器将会采用新建线程的方式来处理请求。</p><p>除去Servlet，与其一同使用的filter同样是同步阻塞的，包括用于处理的HttpServletReq和respon。</p><h3><span id="响应式的运行模式">响应式的运行模式</span></h3><p>Tomcat作为服务器运行模式一来较为重量级，而来每一个请求都会创建新的线程处理的方式对于超高并发大业务会对内存压力较重。除去这种可能出现的问题外，在微服务领域，分布式io可能会出现等待其他服务组件的情况。为了解决这个问题，首先要解决的就是同步阻塞。而对于响应式，则是对非阻塞模式的进一步诠释，当操作完成后，使用通知事件的方式。</p><p>响应式和异步常在前端和客户端中出现，对于客户端中的经典异步响应框架如Rxjava和retrofit组件连用。而在服务器领域，使用的更多的则是Reactor，本身Reactor又与JDK提供的NIO相关，本文就不过多赘述。在Flux中则采用的Reactor，当然Rxjava也是支持的。</p><p>在响应式模式中，提供了一个与CPU核心数相同的线程池来处理请求，由于处理请求的线程不存在阻塞的问题。结合Java1.8中提供的流式编程操作符，来支撑函数式编程的方面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> webflux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx轻量级Http服务器详解</title>
      <link href="/2020/09/02/nginx/"/>
      <url>/2020/09/02/nginx/</url>
      
        <content type="html"><![CDATA[<p>nginx作为平常项目中最常用的反向代理服务器，常用于部署我们的日常开发项目，作为一个路由转发，负载均衡，https配置，静态资源配置的功能。</p><a id="more"></a><h3><span id="反向代理">反向代理</span></h3><p>反向代理的实际工作原理是，代理服务器来接受客户端的网络连接访问请求，然后客户端根据策略，将请求转发给实际中工作的服务器，并让业务服务器处理结果，返回给客户端的过程。</p><p>反向代理服务器有许多优点：</p><ol><li>提高了内部服务器的安全<ul><li>对于外界来说，我们只对外暴露的代理服务器的IP和端口号，内部服务对外部网络完全不可见，而且，代理服务器中不保存信息资源，这样就提高了内部服务的安全性。</li></ul></li><li>加快了对内部服务器的访问速度。</li><li>节约了有限的IP资源，内部网络通过反向代理映射，减少了暴露在公网上的IP地址，解决了IP地址不足的问题。</li></ol><h3><span id="负载均衡">负载均衡</span></h3><p>说到反向代理，不得不提到负载均衡在nginx服务器上的应用。</p><p>负载均衡有一下几种常见的方式。</p><ol><li><p>轮询（默认），每个请求按照时间顺序逐一分配到不同的后端服务器，当后端服务器失效，则自动剔除该服务器。</p></li><li><p>权重方式，指定轮询几率，权重和访问比率成正比，用于后端服务器性能不均匀的情况。</p></li><li><p>ip_hash请求结果经过一次哈希，分配到一个固定的后端服务器。</p></li><li><p>backup模式，主服务器忙的或者失效的时候，请求backup服务器。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>https机制详解</title>
      <link href="/2020/09/02/https/"/>
      <url>/2020/09/02/https/</url>
      
        <content type="html"><![CDATA[<p>在分析https之前，首先要把http搞清楚。</p><p>http本身基于tcp，实际上提供可靠传输的任何一种协议都可以作为http协议的底层传输。</p><h2><span id="http工作原理">Http工作原理</span></h2><p>对于Http协议的，采用了请求/响应模型，客户端向服务端发送一个请求报文，内涵报文的结构的多种数据。服务器收到后将数据响应，返回给客户端，响应报文内容包括协议版本号，成功/错误代码，服务器的部分信息和报文头和响应数据。</p><p>接下来简述http请求/响应的过程：</p><ol><li>客户端和服务器建立连接<ul><li>一个客户端，和Http端口建立一个TCP连接</li></ul></li><li>发送Http请求<ul><li>通过TCP套接字，客户端向服务端发送请求报文，请求报文由请求行、请求头、空行和请求数据组成。</li></ul></li><li>服务器接收响应并返回Http响应数据<ul><li>服务器解析请求，定位请求资源，服务器将响应数据副本写入TCP套接字。一个响应由状态行、响应头、空行和响应体数据组成</li></ul></li><li>释放TCP连接<ul><li>释放TCP连接由两种情况，一种建立的是长连接，建立的状态为KeepAlive，即建立长连接，则保留该连接一段时间，可以继续接受请求。如果连接模式为Close，即短连接，则在请求完成后服务器主动关闭TCP连接，客户端被动关闭连接。</li></ul></li><li>客户端解析响应内容</li></ol><p>看了这个部分，接下来对这个工作原理做一个扩展，将这部分扩展到在浏览器中输入一个域名，直到网站内容出现的过程。</p><h3><span id="网页加载过程分析">网页加载过程分析</span></h3><ol><li>浏览器收到域名后，首先在浏览器本地查找是否由其对应的IP映射，如果不存在，开始查找本机缓存 =&gt; host =&gt; DNS服务器，直到解析URL对应的IP地址。这部分做的是DNS解析的工作。</li><li>接下来解析完成后，与该IP地址建立TCP连接。</li><li>浏览器发送请求报文，作为TCP三次握手的第三个报文的数据发送给服务器。</li><li>服务器对请求做出响应，发送内容到客户端。</li><li>服务器主动释放TCP连接。</li><li>浏览器解析响应数据。</li></ol><h3><span id="http无状态">HTTP无状态</span></h3><p>http本身是无状态的，协议本身不保存之前请求或者响应报文的信息。为了实现状态保存的功能，引入了Cookie机制。</p><h3><span id="http无连接">HTTP无连接</span></h3><p>HTTP本身无连接，处理完请求就断开连接了。但是后续http协议的更新支持一段时间内保持连接，保证在短时间内不会反复建立TCP连接。</p><h3><span id="http方法">HTTP方法</span></h3><p>GET</p><p>HEAD</p><p>POST</p><p>PUT</p><p>DELETE</p><p>TRACE</p><p>OPTIONS</p><p>CONNECT</p><h3><span id="http状态码">HTTP状态码</span></h3><table><thead><tr><th></th><th>类别</th><th>发生原因</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求处理完成</td></tr><tr><td>3XX</td><td>重定向</td><td>需要附加操作完成请求</td></tr><tr><td>4XX</td><td>客户端错误</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器请求出错</td></tr></tbody></table><p>常用的比如说404， 500 ，403， 200等。</p><h3><span id="响应与请求报文构成">响应与请求报文构成</span></h3><h4><span id="请求报文构成">请求报文构成</span></h4><p>请求报文由4部分构成</p><ol><li>请求行<ul><li>在请求行中，包含方法，URL，协议版本</li></ul></li><li>请求头<ul><li>请求头包含头数据，比如Host数据，Content-Type，Connection连接方式，内容长度等。</li></ul></li><li>空行<ul><li>将数据体和头分开</li></ul></li><li>数据体<br> 包含请求数据</li></ol><h4><span id="响应报文构成">响应报文构成</span></h4><p>响应报文与请求报文类似，也是由4部分构成。</p><ol><li>状态行，包含协议版本，状态码，状态码描述。</li><li>响应头，内含响应时间，响应长度，Content-type等数据。</li><li>空行，仍然是分割作用</li><li>响应体，响应的报文数据。</li></ol><h3><span id="http长连接">HTTP长连接</span></h3><p>HTTP的长连接机制是为了减少反复重新建立TCP连接而出现的，减少tcp连接可以减少socket的内核调用。相较于TCP长连接，TCP长连接的keepAlive机制则更有可能导致长时间的系统资源占用。</p><h2><span id="https的基本工作原理">HTTPS的基本工作原理</span></h2><p>HTTPS工作在原本的HTTP的基础上，增加了SSL/TLS协议，共同组成HTTPS的加密数据传输方式。</p><p>在HTTPS中，对称加密和非对称加密共同作用，数据使用对称加密传输，而对于对称加密中的密钥，采用非对称加密传输。</p><p>在HTTPS传输过程中，涉及三个密钥。</p><p>其中两个是服务端生成的公钥和私钥用来进行非对称加密。</p><p>另一个是客户端生成的随机密钥，用来进行对称加密。</p><p>具体流程如下描述：</p><ol><li><p>客户端向服务器发送HTTPS请求，连接到服务器的443端口。</p></li><li><p>服务器收到请求后，将自己手中的公钥发送给客户端。</p></li><li><p>客户端收到服务器的证书后，验证合法性，如果合法，就继续传输，如果不合法，就停止。在合法的情况下，客户端生成一个随机值，用于对称加密的密钥，第一次HTTP请求结束。</p></li><li><p>客户端发起第二个HTTP请求，使用公钥将自己生成的对称加密密钥加密发送给服务端。</p></li><li><p>服务器接收到密文后，使用私钥解密，得到明文的客户端生成的对称加密密钥，服务端将需要响应的数据使用对称加密算法加密，发送给客户端。</p></li><li><p>客户端收到密文，采用对称加密密钥解密得到数据，第二次HTTP请求完成，整个HTTPS请求也完成了。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> https network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pdd-2</title>
      <link href="/2020/08/22/pdd-2/"/>
      <url>/2020/08/22/pdd-2/</url>
      
        <content type="html"><![CDATA[<p>今天面试pdd二面，整体面试感觉很舒服。</p><a id="more"></a><p>简单整理一下提到的问题。</p><ol><li>在实习工作的产出，由于比较保密，所以就没有聊的太深。</li><li>JVM的工作原理简单说一下。</li><li>垃圾回收算法简单说一下</li><li>G1收集器简单说一下，我提到了Eden区和survive区，使用的复制算法和清除整理算法。简单说了一下RememberSet的工作原理。</li><li>多线程了解不，来说一下线程池的几个参数吧。</li><li>既然你说到了工作队列，来说几个常用的工作队列吧（说了三个，他说有4个）</li><li>你平常用的JDK多少啊（我说JDK11），11的新特性有哪些啊（没说，没怎么用新特性）</li><li>现在比较推荐的JDK版本（回答最新的马上出14，11和14都是长时间支持版本）</li><li>好吧，那我们说一些1.8的东西吧，1.8了解哪些（我说流式和ConcurrentHashMap的变化）</li><li>刚好说道CHM，那说说1.8 CHM有什么变化（红黑树，分段锁被CAS的节点锁替换）</li><li>那说一下CAS在1.8 CHM里是怎么用的吧。（说节点锁，采用Unsafe类封装，提高并发粒度）</li><li>那么CAS是怎么保证原子性的呢（这个地方没有答道点子上，说的volatile关键字保证的可见性和防止重排序，面试官说实际上使用的是cpu内部指令，但我说的好像也是对的样子）</li><li>说了CAS，你也提到了红黑树，那我们来说一下红黑树。红黑树的特性是什么。</li><li>红黑树和AVL树有什么区别（脑子抽了没答出来）</li><li>那既然说了红黑树，就来实现一个数据结构吧，实现一个二分查找树吧。（先实现的递归搜索和插入）</li><li>思考一下删除（左右一边为空很快就说出来了，左右同时不为空的情况刚开始没说清楚，后来举例说明白了）</li><li>好的那么我们在做一个题吧：<br>n个小朋友坐成一个环，1号小朋友排一下手，下一轮两边的小朋友也要拍一下手，以此类推，问1号小朋友在m轮游戏后拍了多少次手。（由于笔者还有20分钟就要考试，初始想法是模拟，采用队列的方式，简单给面试官口述了一下，也算是认可了吧）</li><li>智力题，他没给</li><li>反问，问了面试官的部门，问了拼多多未来会不会采用自己的登录模块。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拼多多服务端一面</title>
      <link href="/2020/08/17/pdd-1/"/>
      <url>/2020/08/17/pdd-1/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><ol><li>首先是自我介绍，简单介绍一下自己会的和项目经历。</li><li>30秒内说出2的64次方是多少</li><li>堆内存和栈内存的区别</li><li>TCP和UDP的区别，TCP的有序性体现在哪里。</li><li>协程和线程的区别，协程的优势，协程的实际场景的应用（IO密集型）</li><li>LevelDB（没听过）</li><li>分布式一致性算法（不知道）</li><li>乐观锁和悲观锁在MySQL里的实现方式</li><li>MapReduce的原理，Flink的原理</li><li>算法题：回形数组打印</li><li>智力题，1分钟内说出用3L和5L的量筒称出4L水</li><li>智力题，64匹马，不能计时，最少需要赛跑几次才能选出最快的4匹马</li><li>项目：围绕Redis说了一阵：</li></ol><ul><li>Redis代替Session做分布式缓存</li><li>Redis的几种数据结构</li><li>Redis做缓存优于Mysql做缓存的几个方面</li><li>Redis的淘汰策略</li></ul><ol start="14"><li>项目：围绕数据库说了一下，</li></ol><ul><li>存储过程和函数</li><li>Last_Insert_Id函数的线程安全性</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务实战（一） 建立公共POJO，建立发现注册中心、云端配置中心</title>
      <link href="/2020/06/14/springcloud-5/"/>
      <url>/2020/06/14/springcloud-5/</url>
      
        <content type="html"><![CDATA[<h1><span id="业务假设">业务假设</span></h1><p>我们假设现在有个需求的商城业务，商城业务需要提供：用户服务，物品服务，订单服务，购物车服务。</p><a id="more"></a><h1><span id="提取公共pojo">提取公共POJO</span></h1><p>有了切实的业务需求，那么抽取出系统中通用的POJO，并将其使用Maven打包。</p><h2><span id="建立方式">建立方式</span></h2><p>首先在maven父项目下创建新的maven项目，命名project_common.<br><img src="/img/project_common.png" alt="创建项目"></p><p>在其中创建需要的统一对象。</p><p>我们先创建用户对象和货物对象，同时创建通用响应数据。</p><p><img src="/img/pojo_common.png" alt="创建对象"></p><p>通过使用maven打包，可以让项目中的其他子模块访问。</p><p>编写pom.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>project.com<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">maven.compiler.encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建maven运行指令：</p><p><img src="/img/enter_config.png" alt="选择创建"></p><p><img src="/img/maven_command.png" alt="创建指令"></p><p>然后运行指令。</p><h1><span id="建立发现注册中心">建立发现注册中心</span></h1><p>参照本教程的前驱教程，设置自己的发现注册中心</p><h1><span id="建立云端配置中心">建立云端配置中心</span></h1><p>在此处介绍一个云端配置中心的概念，spring cloud config，该模块的功能是提供一个公共配置中心，项目的配置文件从配置中心读取，配置中心从github上读取。</p><p>首先介绍maven依赖文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--依赖父项目--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project_web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.config<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR5<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入云端配置中心--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后编写配置文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#配置中心程序名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">project-config-center</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="comment">#读取的github仓库</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/zhangyonglele/springcloudcofig/</span></span><br><span class="line">          <span class="comment">#用户名</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">zhangyonglele</span></span><br><span class="line">          <span class="comment">#密码</span></span><br><span class="line">          <span class="attr">password:</span> <span class="comment">############</span></span><br><span class="line">      <span class="comment">#文件所在的分支   </span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6869</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/,http://localhost2:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">project-config-center-6869</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">info:</span></span><br></pre></td></tr></table></figure><p>在启动程序上添加启动注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样云端配置中心就配置完成了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springcloud实战(三) Zuul网关与非授权访问拦截</title>
      <link href="/2020/06/14/springcloud-7/"/>
      <url>/2020/06/14/springcloud-7/</url>
      
        <content type="html"><![CDATA[<p>我们采用zuul网关来联合过滤我们的内部服务是否可以被访问到，防止外部未授权访问越界访问内部微服务。</p><a id="more"></a><p>有些人可能会问，即使我们使用了网关，外界依然可以通过端口号访问。</p><p>实际上我们需要配置服务器安全组，或是防火墙，屏蔽其他端口，仅留下网关端口供外界访问即可。</p><h2><span id="网关路由配置">网关路由配置</span></h2><p>如果需要maven依赖，可以去查阅前面的部分，我们这里直接开始编写配置文件。</p><p>当然你也可以编写云端配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7799</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-zuul-gateway</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#指定微服务发现中心</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/,http://localhost2:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">user-zuul-7799</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="comment">#路由配置，这里的路由配置可以自己起名</span></span><br><span class="line">    <span class="attr">test-api:</span></span><br><span class="line">      <span class="comment">#指定用户转发路由，即将/user/**转发到project-user-service中，即/user/login转发到服务的/login</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">project-user-service</span></span><br><span class="line">      <span class="comment">#设置通过网关保存session访问</span></span><br><span class="line">      <span class="attr">sensitiveHeaders:</span> <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment">#配置redis</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">5MB</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#Redis config</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="comment"># Redis password</span></span><br><span class="line">    <span class="comment">#password: 123456</span></span><br><span class="line">    <span class="comment"># connection timeout maximum accept 2000ms</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">2000ms</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment"># Maximum connection pool size</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># Maximum blocking time accept, negative number represent no limitation</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">-1ms</span></span><br><span class="line">        <span class="comment"># Maximum free connection accept</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># Minimum free connection accept</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">## Entry expiration in milliseconds. By default the entries never expire.</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="string">1d</span></span><br><span class="line">      <span class="comment"># Writing to Redis need key prefix</span></span><br><span class="line">      <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">session:</span></span><br><span class="line">    <span class="attr">store-type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">30M</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure><p>在启动类上打开配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span> <span class="comment">//启动分布式session</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//启动发现服务</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">//启动zuul</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserZuulApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下俩编写拦截业务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserLoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定在过滤前启动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定过滤顺序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext current = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = current.getRequest();</span><br><span class="line">        String url = request.getRequestURI();</span><br><span class="line">        log.info(url);</span><br><span class="line">        <span class="comment">//如果是login请求，则直接通过</span></span><br><span class="line">        <span class="keyword">if</span>(url.contains(<span class="string">"login"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则访问被过滤</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext current = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = current.getRequest();</span><br><span class="line">        <span class="comment">//获取请求的session</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        <span class="comment">//获取session授权信息</span></span><br><span class="line">        String auth = (String) session.getAttribute(<span class="string">"auth"</span>);</span><br><span class="line">        <span class="keyword">if</span>(auth == <span class="keyword">null</span> || !auth.equals(<span class="string">"ok"</span>))&#123;</span><br><span class="line">            <span class="comment">//如果访问未授权，则拦截</span></span><br><span class="line">            current.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            current.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.getResponse().getWriter().write(<span class="string">"&#123;\"errorCode\":-1,\"message\":\"auth refuse\"&#125;"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则通过</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springcloud微服务实战(二) 创建用户服务</title>
      <link href="/2020/06/14/springcloud-6/"/>
      <url>/2020/06/14/springcloud-6/</url>
      
        <content type="html"><![CDATA[<p>本章介绍如何创建基本用户服务。</p><a id="more"></a><h2><span id="创建服务的基本依赖">创建服务的基本依赖</span></h2><p>首先提供我们在前一节创建出的User实例代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userEmail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span>  serializableId = -<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserPassword</span><span class="params">(String userPassword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userPassword = userPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserEmail</span><span class="params">(String userEmail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userEmail = userEmail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们使用的是mybatis ORM层框架，所以需要提供set get方法。</p><p>接下来创建用户服务 project-service</p><p>提供maven文件依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project_web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.user<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>user<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR5<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入redis操作和Redis分布式session解决方案--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入eureka发现组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入云端配置中心的客户端，用于从配置中心读取配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入mysql驱动--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入我们前面自己写的公共POJO--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>project.com<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下俩我们编写配置文件，由于我们从云端读取配置，所以需要两份配置文件。</p><p>首先是原本的application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#指定user服务的名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">project-user-service</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用mybatis，配置mybatis文件</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">pojo</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapping/*.xml</span></span><br></pre></td></tr></table></figure><p>接下来是配置和application.yml同路径下，从云端读取配置文件的配置。</p><p>bootstrap.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">database-config</span> <span class="comment">#需要从github上读取的资源名称，注意没有yml后缀名</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span>   <span class="comment">#本次访问的配置项</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:6869</span> <span class="comment">#本微服务启动后先去找6869号服务，通过SpringCloudConfig获取GitHub的服务地址</span></span><br></pre></td></tr></table></figure><p>http请求地址和资源文件映射如下:</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>即我们读取的是<a href="https://github.com/zhangyonglele/springcloudcofig/master/database-config-dev.yml。" target="_blank" rel="noopener">https://github.com/zhangyonglele/springcloudcofig/master/database-config-dev.yml。</a></p><p>配置完成后目录接口如下：</p><p><img src="/img/cloud_config.png" alt="配置"></p><h2><span id="启动类">启动类</span></h2><p>启动类需要大量的注解来启动各类服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>  <span class="comment">//启动redis session</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.user.user.mapper"</span>) <span class="comment">//指定mapper位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他部分与常规springboot程序相似。</p><p>分析一个业务，登录业务，因为其用到了spring session分布式解决方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/info"</span>,produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UniversalResponseBody <span class="title">getUserInfoByUserEmail</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span> String email)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UniversalResponseBody(<span class="number">0</span>,<span class="string">"success"</span>,userService.getUserByEmail(email));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该注解指定访问url为/login,指定返回数据类型为json，方法为get方法</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/login"</span>,produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UniversalResponseBody <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"email"</span>)</span>String email,</span></span><br><span class="line"><span class="function">                                       @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span>String password,</span></span><br><span class="line"><span class="function">                                       HttpSession session)</span>&#123;</span><br><span class="line">        <span class="comment">//尝试获取用户数据</span></span><br><span class="line">        User user = userService.getUserByEmail(email);</span><br><span class="line">        <span class="comment">//判断用户数据是否符合要求</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span> || user.getUserEmail().equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UniversalResponseBody(-<span class="number">1</span>,<span class="string">"error"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(user.getUserPassword().equals(password))&#123;</span><br><span class="line">                <span class="comment">//符合要求后写入redis session</span></span><br><span class="line">                session.setAttribute(<span class="string">"auth"</span>,<span class="string">"ok"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UniversalResponseBody(<span class="number">0</span>,<span class="string">"success"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UniversalResponseBody(-<span class="number">1</span>,<span class="string">"error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时可以采用md5的加密方式，防止明文存储数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务框架(4) Zuul路由转发和过滤器</title>
      <link href="/2020/05/10/springcloud-4/"/>
      <url>/2020/05/10/springcloud-4/</url>
      
        <content type="html"><![CDATA[<h1><span id="zuul简介">Zuul简介</span></h1><p>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。<br><a id="more"></a></p><h1><span id="准备">准备</span></h1><p>新创建一个springboot程序，再pom.xml中引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-zuul-7799<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>microservice-zuul-7799<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2><span id="开始使用">开始使用</span></h2><p>在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceZuul7799Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MicroserviceZuul7799Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上配置文件application.yml加上以下的配置代码：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7799</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/,http://localhost2:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">mircoservice-zuul-7799</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">  <span class="comment">#这里配置路由转发，将访问/test/**的请求转发到mircoservice-feign服务中</span></span><br><span class="line">    <span class="attr">test-api:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/test/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">mircoservice-feign</span></span><br><span class="line">    <span class="attr">ribbon-api:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/ribbon/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">mircoservice-ribbon</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">microservice-zuul-gateway</span></span><br></pre></td></tr></table></figure></p><p>访问localhost:7799/test/hello和访问前面编写的localhost:7778/hello效果相同，起到了路由转发的功能。</p><h2><span id="服务过滤">服务过滤</span></h2><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；</p><p>创建文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示在路由之前启动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//过滤顺序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在何种情况下过滤</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext current = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = current.getRequest();</span><br><span class="line">        <span class="comment">//检测是不是带有token参数并且为空</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span>(token == <span class="keyword">null</span> || token.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            current.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            current.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.getResponse().getWriter().write(<span class="string">"&#123;\"errorCode\":-1,\"message\":\"auth refuse\"&#125;"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：</p><ul><li>pre：路由之前</li><li>routing：路由之时</li><li>post： 路由之后</li><li>error：发送错误调用<br>filterOrder：过滤的顺序<br>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。<br>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li></ul><blockquote><p>访问localhost:7799/test/hello，返回{“errorCode”:-1,”message”:”auth refuse”}</p><p>但是访问localhost:7799/test/hello?token= 后则正常返回服务</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务框架(3) Hystrix断路器（基于Feign的实现）</title>
      <link href="/2020/04/11/springcloud-3/"/>
      <url>/2020/04/11/springcloud-3/</url>
      
        <content type="html"><![CDATA[<p>断路器的功能是当服务集群与Feign客户端意外断开连接后，外界的服务依旧可能通过Feign试图访问异常服务。Hystrix断路器的功能就是当异常服务断开连接时间达到阈值，则主动将该服务与Feign客户端断开，并且返回指定的fall back响应。<br><a id="more"></a></p><h2><span id="基于feign的断路器实现">基于Feign的断路器实现</span></h2><p>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它。</p><p>在application.yml文件中加入<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">#启动熔断器</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>按照前面文章编写yml文件的读者可以注意文件中是否已经打开。</p><p>在Client接口中指定fallback</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"mircoservice-test"</span>,fallback = HelloClientHystric<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Fallback方法，注意要实现现在编写的Client接口，并通过@Component注解注入bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClientHystric</span> <span class="keyword">implements</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sorry can't visit"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将正在运行的正常服务提供者关闭，就会返回指定的fallback方法内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务框架(2) Feign</title>
      <link href="/2020/04/10/springcloud-2/"/>
      <url>/2020/04/10/springcloud-2/</url>
      
        <content type="html"><![CDATA[<h1><span id="创建服务消费者">创建服务消费者</span></h1><a id="more"></a><p>承接上文，在创建完服务提供者后，我们就需要创建服务消费者，作为外界访问服务集群的对外接口，同时承担负载均衡的作用。</p><h2><span id="feign客户端服务">Feign客户端服务</span></h2><p>Feign的功能是封装了http的请求，通过http的方式来实现对内部服务的调用和负载均衡的功能。</p><p>在父项目下按照前文相同的方式创建子项目，这次需要引入的feign依赖，同样先贴出maven依赖引入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-comsumer-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>microservice-comsumer-feign<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入maven依赖后，我们需要对所有的服务使用统一进行代理，所以开始对Feign客户端开始编写。</p><p>对于springcloud项目，最重要的就是对配置文件的编写，所以我们先编写配置文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#指定端口号</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7778</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#指定服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mircoservice-feign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#指定注册中心</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/,http://localhost2:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#声明该服务实例的id</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">mircoservice-feign-7778</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment">#启动熔断器</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>配置文件编写完成后，在编写启动类的声明部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//指定这个服务可以被服务中心发现，是一个被注册进入服务中心的服务</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">//指定该服务为Feign客户端，启动feign服务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceComsumerFeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MicroserviceComsumerFeignApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在声明该程序为feign代理后，编写代理客户端的功能。</p><p>然后编写客户端接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"mircoservice-test"</span>,fallback = HelloClientHystric<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对@FeignClient接口的说明：</p><p>这个注解的功能是声明该接口为feign代理客户端，value中输入注册在服务中心里服务的名称，比如我们在上一篇文章中提供的服务mircoservice-test。而fallback是熔断器相关，以后再进行讲解。</p></blockquote><p>本feign客户端代理的是mirocservice-test服务，那么我们在这里指定，和这个服务相同的url接口，比如说这里指定的hello接口，意思就是通过feign来代理mirocservice-test服务提供的hello接口，并对集群部署的服务进行默认的轮询式负载均衡。</p><p>然后通过controller服务调用该客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代理的客户端</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外界访问时的指定的接口</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloClient.sayHello() + <span class="string">" from feign"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>访问localhost:7778/hello，就可以输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello from **** from feign</span><br></pre></td></tr></table></figure></p><p>这里的<em>**</em>是服务所存在的端口号，如果需要测试集群部署服务，则按照上一篇文章的方法，换一个端口号再创建一个服务提供者即可。</p><p>比如说我在7245和7244端口部署两个相同的服务，并且注册到服务中心。那么这里访问localhost:7778/hello，则会交替出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello from 7244 from feign</span><br><span class="line"></span><br><span class="line">hello from 7245 from feign</span><br></pre></td></tr></table></figure><h2><span id="ribbon">Ribbon</span></h2><p>Ribbon可以实现相同的功能，具体请各位再自行学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美团一面面经</title>
      <link href="/2020/04/02/meituan-1/"/>
      <url>/2020/04/02/meituan-1/</url>
      
        <content type="html"><![CDATA[<p>究极猛男，今天美团一面究极刺激，普通知识一大堆，问到的盲区也不少，做个整理。</p><p><strong>然后就是尼玛的迭代先序二叉树！！！！！！尼玛的脑子抽了！！！！！！</strong></p><a id="more"></a><p>凉了就凉了吧，心理准备好了，面试官人很nice，说话很和蔼，问问题虽然有点严肃，但是真的很不错。</p><p>一个小时的面试，强度还是很高的。</p><ol><li><p>java集合，list和set的区别</p></li><li><p>线程池，最后的最后handlr要说几个只说了一个，拉跨了，还有一个corePollSize怎么设置，这个也击中知识盲区</p></li><li><p>sychronized和volatile</p></li><li><p>fianl和static</p></li><li><p>重排序相关</p></li><li><p>atomNumber相关</p></li><li><p>reentranLock重入锁是怎么实现的(这个答得莫能两可，感觉很差)</p></li><li><p>Callable和FutrueTask</p></li><li><p>ThreadLocal</p></li><li><p>各种引用方式，弱引用，强应用，幻影引用，最后软引用(没答上来)</p></li><li><p>JVM相关，数据区，回收算法，类加载器有哪些（没答出来），双亲委派机制</p></li><li><p>mysql相关Innodb索引结构，数据库隔离级别（莫名其妙答成几种情况了），最左匹配原则（好像答错了）</p></li><li><p>数据库中的乐观锁和悲观锁</p></li><li><p>CAS</p></li><li><p>spring的事务传播级别（没答上），bean装载的方式，aop</p></li><li><p>代理模式的实现手段，答了三个JDK,CGLIB,ASPECTJ</p></li><li><p>计算机网络，TCP流量控制</p></li><li><p>mybatis $和#的区别</p></li><li><p>redis为什么快，写入磁盘的两种方式，redis中的key过期时间怎么实现的</p></li><li><p>cookie和session的区别，过期时间怎么实现的</p></li><li><p>MAP是怎么实现寻找功能的</p></li><li><p>手撕二叉树迭代先序遍历</p></li></ol><p>我再不会写我是dog。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTranver</span><span class="params">(Node tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.print(tree.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(tree != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(tree);</span><br><span class="line">            tree = tree.left;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            tree = stack.pop();</span><br><span class="line">            tree = tree.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-mvc-framework-3</title>
      <link href="/2020/03/29/my-mvc-framework-3/"/>
      <url>/2020/03/29/my-mvc-framework-3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java工厂模式 与 抽象工厂模式</title>
      <link href="/2020/03/22/java-factory/"/>
      <url>/2020/03/22/java-factory/</url>
      
        <content type="html"><![CDATA[<p>工厂模式的核心思想是延后实例化时间，让创建对象这个过程延迟到子类进行。从而不用知道具体是哪个类进行的实例化，也不用了解这个类实例化需要的参数和具体过程。我们只用知道这个类的名称就可以来进行实例化了。<br><a id="more"></a><br>通过一个接口，某些继承这些接口的类不进行主动实例化，而是通过一个“工厂”来决定生产什么类，调用工厂的地方只需要指定实例化哪一个类就可以了。</p><h2><span id="传统工厂类型">传统工厂类型</span></h2><p>传统工厂类型，通过定义一个通用接口，让其他继承此接口的类被一个公用工厂实例化。不需要知道每个类是如何实例化或者类确切的名字。</p><p><img src="/img/factory.jpg" alt="factory"></p><p>让我们用代码实现他，同时使用枚举类来优化工厂创建过程。</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义两种不同品牌的TV<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiTV</span> <span class="keyword">implements</span> <span class="title">TV</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuaweiTV</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HWproduct ID id"</span> + ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Huawei Showing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiTV</span> <span class="keyword">implements</span> <span class="title">TV</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMiTV</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Miproduct ID id"</span> + ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"XiaoMi Showing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后为了防止外部调用者知道内部构造实现，我们使用工厂封装其创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TVFactory&#123;</span><br><span class="line">    HuaweiTV,XiaoMiTV;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TV <span class="title">newTV</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> HuaweiTV:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> HaweiTV(<span class="number">9930</span>);</span><br><span class="line">            <span class="keyword">case</span> XiaoMiTV:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiTV(<span class="number">3270</span>);</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"无效参数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在外部调用工厂类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    TVFactory.HuaweiTV.newTV().show();;</span><br><span class="line">    TVFactory.XiaoMiTV.newTV().show();;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得到结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HWproduct ID id9930</span><br><span class="line">Huawei Showing</span><br><span class="line">Miproduct ID id3270</span><br><span class="line">XiaoMi Showing</span><br></pre></td></tr></table></figure></p><h2><span id="抽象工厂类型">抽象工厂类型</span></h2><p>抽象工厂模式实际上是一种工厂的工厂，它定义了一个工厂的规范，当某个类继承了某个接口或是抽象类，便是继承了某一种工厂规范，继承了这种工厂规范，便需要实现工厂规范中设计的产品。</p><p>我们同样以H厂和M厂来举例子。</p><p>首先定义工厂规范，除了TV以外，这两个厂子还生产Phone。TV我们沿用上面定义的TV</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> tel)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuaweiPhone</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HW Phone ID id"</span> + ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> tel)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Huawei call the number:"</span> + tel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaoMiPhone</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Mi Phone ID id"</span> + ID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"XiaoMi call the number:"</span> + tel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以定义一种工厂叫做EEFactory，用于生产手机和电视。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EEFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">(<span class="keyword">int</span> ID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TV <span class="title">makeTV</span><span class="params">(<span class="keyword">int</span> ID)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义H家和M家不同的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFactory</span> <span class="keyword">implements</span> <span class="title">EEFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone(ID);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">makeTV</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiTV(ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">EEFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiPhone(ID);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">makeTV</span><span class="params">(<span class="keyword">int</span> ID)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaoMiTV(ID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以通过EE工厂来接受H家的工厂和M家的工厂来实例化对象啦，同样可以采用上面的方式，也就是枚举类+内部类的方式来优化抽象工厂模式，让EE工厂成为一个枚举类，在通过将两家的实体工厂内部成为静态方法，静态就可实例化对象，非常的方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试构造出自己的MVC框架（二），IOC和DI的实现</title>
      <link href="/2020/03/21/my-mvc-framework-2/"/>
      <url>/2020/03/21/my-mvc-framework-2/</url>
      
        <content type="html"><![CDATA[<h1><span id="第二天">第二天</span></h1><p>在Spring中，常常使用@AutoWired的方式来进行IOC的操作，从而实现DI。这里在对Bean管理的实现基础上，就可以实现对所有被管理的Bean进行IOC的实现。</p><a id="more"></a><p>IOC，也就是控制反转，其中最常见的实现方式就是DI（依赖注入）。常用的注入方式有三种，基于接口，基于setter，基于构造函数，笔者由于比较懒，只实现基于接口的DI。同时基于接口的DI，也是我们比较常见的一种方式，但是这种方式有一定的缺陷。在这里不对这种缺陷具体描述。</p><p>既然是基于接口的DI，那么我们就要对某一个接口来注入某个实现了该接口的类，从而不用手动来new这个类。</p><p>在常见的spring操作中，是如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> SomeService someService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样之后，实现了SomeService接口的类就会被自动注入到这个引用中，而我们在今天的任务就是实现注入。</p><h2><span id="自定义注解为需要管理的bean示例打上tag">自定义注解，为需要管理的Bean示例打上tag</span></h2><p>我们实现在Spring中常用的几种注解，分别是Controller，Service，Component。同时实现AutoWired来实现DI。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里指定AutoWired只能打在成员变量身上</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoWired &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Service &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="基于注解实现ioc">基于注解实现IOC</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeansHome beansHome;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        beansHome = BeansHome.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实现某个接口的类，用于准备IOC注入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaceClass 被实现的接口名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个被定位到的实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getImplementClass(<span class="keyword">final</span> Class&lt;?&gt; interfaceClass)&#123;</span><br><span class="line">        <span class="keyword">return</span> beansHome.getExtendingClass(interfaceClass)</span><br><span class="line">                .stream()</span><br><span class="line">                <span class="comment">//由于默认一个接口只有一个实现类所以可以用这种方式，如果一个接口有多个实现类则这个方法就会出现问题</span></span><br><span class="line">                .findFirst()</span><br><span class="line">                .orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类获取类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用Optional优雅解决判空问题</span></span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(beansHome.getBean(clazz))</span><br><span class="line">                .orElse(</span><br><span class="line">                        Optional.ofNullable(beansHome.getBean(getImplementClass(clazz))).orElse(<span class="keyword">null</span>)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取所有的bean示例，依次进行依赖注入</span></span><br><span class="line">        <span class="keyword">for</span>(Class&lt;?&gt; clazz : beansHome.getAllClasses())&#123;</span><br><span class="line">            <span class="comment">//获取bean</span></span><br><span class="line">            <span class="keyword">final</span> Object bean = beansHome.getBean(clazz);</span><br><span class="line">            <span class="comment">//获取bean上的成员变量</span></span><br><span class="line">            Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">            <span class="comment">//遍历成员变量</span></span><br><span class="line">            <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">                <span class="comment">//检测该成员变量是否被@AutoWired标注</span></span><br><span class="line">                <span class="keyword">if</span>(field.isAnnotationPresent(AutoWired<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">                    <span class="comment">//如果被标注，获取获取该变量</span></span><br><span class="line">                    <span class="keyword">final</span> Class&lt;?&gt; fieldClass = field.getType();</span><br><span class="line">                    <span class="comment">//获取到被标注的变量类型</span></span><br><span class="line">                    Object fieldValue = getInstance(fieldClass);</span><br><span class="line">                    <span class="keyword">if</span>(fieldValue != <span class="keyword">null</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果存在，则调用在前一章写到的方法进行注入</span></span><br><span class="line">                        ClassHelper.setField(field,bean,fieldValue);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"注入失败，试图注入"</span>+fieldClass.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务框架(1) 服务的发现和注册</title>
      <link href="/2020/03/19/springcloud-1/"/>
      <url>/2020/03/19/springcloud-1/</url>
      
        <content type="html"><![CDATA[<p>SpringCloud，一个神奇的微服务框架，他的功能在于将一个大的spring服务，拆分成多个小的部件，各负责一部分功能，从而减小每个部件的体积和内容，每个服务组件只用专注于一个很小的部分，效率比较高。同时又是松耦合结构，开发和部署都是独立进行的。</p><a id="more"></a><p>于此同时的代价就是开发人员要面对分布式系统的部分复杂问题。大量的分布式组件也会使得维运变得困难。服务之间的内部调用网络深不见底。数据一致性问题也需要分布式锁同步才能实现。各组件间的通信成本也比较高。</p><p>那么就开始微服务的入门和配置开发吧。</p><p>首先对微服务的架构和内容做一些讲解，以便于比较好的理解微服务。</p><h1><span id="cap理论">CAP理论</span></h1><p>什么是cap理论呢，CAP理论有一点像ACID理论。具体来说：</p><ol><li>C:consistency，数据一致性，数据一致性要求所有节点拥有最新版本的数据。</li><li>A:availability，可用性，数据要求具有高可用性。</li><li>P:partition-tolerance，容忍网络出现分区，分区值之间网络不可达</li></ol><p>在CAP理论上，这三点是不可能共存的，最多实现两种，CA,AP,CP都是可以的。</p><p>但是这里指的其实是一种极端一致和极端可用，并不是说选择了一种另一种就完全不能保证。</p><p>由于在分布式系统中，分区容错性是必须要保证的，所以我们只能在AC中选择一个来实现。</p><h1><span id="springcloud服务的基本架构">SpringCloud服务的基本架构</span></h1><p>在SpringCloud中，要将一个大型服务拆分成多个小服务，要解决的问题如下：</p><ol><li>多组件的统一管理（解决方案：高可用性的服务注册和发现组件Eureka）</li><li>单一服务的集群化配置，服务提供的实体</li><li>代理集群式服务的统一接口，即消费提供的服务的接口（feign和ribbon），并提供负载均衡的功能。以及微服务之间的调用</li><li>当集群化服务中的某个服务与代理接口连接超时，自动熔断连接（Hystrix熔断器）</li><li>分布式服务器的负载均衡和请求分发（zuul实现的负载均衡）</li><li>服务器内部的网关集群和网关过滤器（zuul实现的网关和权限控制集群）</li><li>分布式服务的通用化配置文件读取和自动配置（config）</li></ol><p><img src="/img/springcloud.jpeg" alt="springcloud服务架构"></p><p>Springcloud并不是通过rpc的方式来调用服务的，而是通过http接口，所以对传统后端开发者来说比较友好，上手非常快同时也比较好理解。</p><h1><span id="准备工作">准备工作</span></h1><p>修改hosts文件，将127.0.0.1 localhost修改为</p><p>127.0.0.1 localhost1 localhost2</p><p>在idea中首先创建一个maven项目，作为springcloud测试项目的父项目，统一管理一部分依赖.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>microservice-eureka<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>mircoservice-eureka-7002<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1><span id="eureka服务注册和发现">Eureka服务注册和发现</span></h1><p>在父项目中创建module，可以使用IDEA提供的spring initializr，引入spring cloud discovery中的eureka server，首先创建一个Eureka服务注册中心：</p><p>子项目pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>microservice-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在项目启动入口上加上启动Eureka Server的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">//启动eureka服务器</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceEurekaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MicroserviceEurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中编写：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost1</span> <span class="comment">#eureka服务端的实例名称(这里使用了虚拟主机映射，修改hosts文件即可实现)</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#单机 defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">      <span class="comment">#设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/</span></span><br></pre></td></tr></table></figure><p>然后启动项目，访问localhost1:7001，就可以看到服务注册的信息了。</p><h2><span id="高可用性的eureka注册中心">高可用性的Eureka注册中心</span></h2><p>和上面讲解的一样，再创建一个eureka server子项目，只对这两个eureka server项目的配置文件进行修改：</p><p>eureka1:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost1</span> </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     </span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     </span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost2:7002/eureka/</span> <span class="comment">#这里修改为其他eureka的服务地址，多个则用逗号隔开</span></span><br></pre></td></tr></table></figure><p>eureka2:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span>     </span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span>     </span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/</span> <span class="comment">#这里修改为其他eureka的服务地址，多个则用逗号隔开</span></span><br></pre></td></tr></table></figure></p><p>然后访问任意节点的控制中心，就可以在DS Replicas看到其他eureka服务的出现。</p><h2><span id="eureka的自我保护机制">Eureka的自我保护机制</span></h2><p>默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。</p><ol><li><p>自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。</p></li><li><p>自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制</p></li></ol><p>注意：该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务。 如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。 所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。</p><h1><span id="创建服务提供者">创建服务提供者</span></h1><p>在注册注册中心创建完成后，我们再来尝试一下向注册中心中注册一个web服务。</p><p>在项目中创建子项目，同样使用spring initializr，然后编写pom.xml依赖文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springclouldtest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>microservice-provider-7245<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>microservice-provider-7245<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入依赖后，设置application.yml配置文件：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="comment">#指定端口号</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7245</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment">#向注册中心声明自己的服务名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mircoservice-test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment">#指定注册注册中心位置</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost1:7001/eureka/,http://localhost2:7002/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#本实例在注册中心的id信息</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">mircoservice-provider-7245</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">info:</span></span><br></pre></td></tr></table></figure></p><p>在程序运行入口增加注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span> <span class="comment">//将程序声明为eureka客户端注册进服务中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroserviceProvider7245Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MicroserviceProvider7245Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后编写测试Controller<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello from "</span>+port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后启动服务中心，再启动服务提供者。</p><p>访问服务中心:localhost:7001</p><p><img src="/img/springcloud-provider-start.png" alt="注册中心"></p><p>可以发现服务已经被注册进服务中心了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尝试构造出自己的MVC框架（一），Bean管理和Bean自动装配</title>
      <link href="/2020/03/08/my-mvc-framework-1/"/>
      <url>/2020/03/08/my-mvc-framework-1/</url>
      
        <content type="html"><![CDATA[<p>在系统学习了多线程和设计模式之后，想利用自己学到的知识，结合Spring框架的部分IOC，DI,AOP思想，构造出自己的MVC框架。</p><a id="more"></a><p>在开篇要感谢博主的原文给我的灵感和动力，参考了他不少的代码架构和部分思路，同时加以自己的学习实践。<a href="https://github.com/zzzzbw/doodle" target="_blank" rel="noopener">原作者github地址</a>。</p><h1><span id="第一天bean的管理和bean的装配">第一天：Bean的管理和Bean的装配</span></h1><p>在Spring框架中，Bean的管理和自动装配是交给Spring管理的，在开始运行程序的时候，就通过反射的方式将类进行实例化，并且形成单例模式的各个类(这点存疑，Spring本身可以选择是以单例模式实现还是以原型模式实现，在本文的实现中我将尽可能的采用单例模式)。</p><p>所以Bean的初始化和装配就是框架的最基础的部分。</p><p>Spring是通过注解的方式，扫描项目并且将自己编写的类装载在Beans中的，所以第一步就是需要创建一个Bean的存储和管理机制。</p><p>Bean实际上就是一个一个要被程序加载的类实例，在一个web容器中，需要来管理每一个编写的类方法，而这就是类容器。</p><p>微型框架采用比较简单的HashMap直接进行管理就可以。</p><p>首先将整个一份代码发上来，该部分用于构建bean管理器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansHome</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储BeansHome唯一实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> BeansHome instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断Beans是否被加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isLoad;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义过的注解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; ANNOTATIONS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ANNOTATIONS = Arrays.asList(Controller<span class="class">.<span class="keyword">class</span>, <span class="title">Component</span>.<span class="title">class</span>, <span class="title">Service</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储beans的根基</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;,Object&gt; beans = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有化构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BeansHome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isLoad = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkLoadingStatus</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isLoad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重校验锁方式实现单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeansHome <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BeansHome<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> BeansHome();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取bean实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(clazz == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beans.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入Bean实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">putBean</span><span class="params">(Class&lt;?&gt; clazz,Object singletonObj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.put(clazz,singletonObj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HashSet&lt;Object&gt; <span class="title">getAllBeans</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;Object&gt;(beans.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有类</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAllClasses()&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBean</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        beans.remove(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BeansHome大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">BeansHomeSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有被某种注解设置的Class</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getAnnotationClass(Class&lt;? extends Annotation&gt; annotation)&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.keySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(p -&gt; p.isAnnotationPresent(annotation))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过实现类或者父类来获取的Class</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getExtendingClass(Class&lt;?&gt; superClass)&#123;</span><br><span class="line">        <span class="keyword">return</span> beans.keySet()</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(superClass::isAssignableFrom)</span><br><span class="line">                .filter(p -&gt; !p.equals(superClass))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Beans全部初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initBeansHomeAndLoad</span><span class="params">(String packageName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(checkLoadingStatus())&#123;</span><br><span class="line">            log.error(<span class="string">"Beans管理器已经被加载"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//先将加载情况置于被加载</span></span><br><span class="line">            isLoad = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//防止出现多线程加载bean的情况</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Set&lt;Class&lt;?&gt;&gt; beans = ClassHelper.getPackageClass(packageName);</span><br><span class="line">                    beans.stream().filter(bean -&gt; &#123;</span><br><span class="line">                        <span class="keyword">for</span>(Class&lt;? extends Annotation&gt; anno : ANNOTATIONS)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(bean.isAnnotationPresent(anno))&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;).forEach(bean -&gt; <span class="keyword">this</span>.beans.put(bean,ClassHelper.newInstance(bean)));</span><br><span class="line">                &#125;<span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">                    isLoad = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类被重复加载"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkLoadingStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="1bean管理器的设计模式">1.bean管理器的设计模式</span></h2><p>为了让整个程序只实例化一份bean，原因很多服务只需要一个实例。所以将管理器设计为单例模式，这里使用了双重校验锁的懒加载来创建单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重校验锁方式实现单例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeansHome <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (BeansHome<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> BeansHome();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-bean的自加载">2. bean的自加载</span></h2><p>在一个web程序中，只有被我们所创建的注解所标记的类才会被加载，为了获取这个类是否被注解，就需要使用反射来获取到所有类的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Beans全部初始化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initBeansHomeAndLoad</span><span class="params">(String packageName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(checkLoadingStatus())&#123;</span><br><span class="line">        log.error(<span class="string">"Beans管理器已经被加载"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//先将加载情况置于被加载</span></span><br><span class="line">        isLoad = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//防止出现多线程加载bean的情况</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Set&lt;Class&lt;?&gt;&gt; beans = ClassHelper.getPackageClass(packageName);</span><br><span class="line">                <span class="comment">//使用流式遍历指定项目/包中所有的类，检查是否被编写的注解所注释</span></span><br><span class="line">                beans.stream().filter(bean -&gt; &#123;</span><br><span class="line">                    <span class="keyword">for</span>(Class&lt;? extends Annotation&gt; anno : ANNOTATIONS)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(bean.isAnnotationPresent(anno))&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//接下来把符合要求的类，将类使用反射的方式加载到bean管理器中</span></span><br><span class="line">                .forEach(bean -&gt; <span class="keyword">this</span>.beans.put(bean,ClassHelper.newInstance(bean)));</span><br><span class="line">            &#125;<span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">                isLoad = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类被重复加载"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkLoadingStatus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean的自加载本身需要使用反射的机制遍历包中所有的类，我也将一部分遍历包的代码放在此处，一来熟悉对文件的IO操作，二来熟悉反射的一般应用。</p><h2><span id="使用反射方式加载类">使用反射方式加载类</span></h2><p>使用反射的方式加载类，不再需要将编写的类手动实例化，而是交给bean管理器来管理，在这个部分，就需要文件IO来读取项目中的类，然后使用反射加载，否则将无法加载框架以外的类文件，而且所有的类必须手动实例化，有了反射就可以自动搜索项目文件中的类了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装载并获取装载的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 类实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadAndGetClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">            log.error(<span class="string">"load class error, Maybe program never find your class"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类名来实例化一个类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classname</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(String classname)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = loadAndGetClass(classname);</span><br><span class="line">            <span class="keyword">return</span> (T)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"类实例化失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过某种确定的类实例化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"类实例化失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类的路径来获取类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> classPath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packagePath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getClassByPath(Path classPath,Path packagePath,String packageName)&#123;</span><br><span class="line">        String packageNameTest = classPath.toString().replace(packagePath.toString(),<span class="string">""</span>);</span><br><span class="line">        String className = (packageName + packageNameTest).replace(<span class="string">"/"</span>,<span class="string">"."</span>)</span><br><span class="line">                .replace(<span class="string">"\\"</span>,<span class="string">"."</span>)</span><br><span class="line">                .replace(<span class="string">".class"</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> loadAndGetClass(className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从包路径获取包内所有类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回包内的所有类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Class&lt;?&gt;&gt; getPackageClass(String packageName)&#123;</span><br><span class="line">        <span class="comment">//获取到加载的路径</span></span><br><span class="line">        URL url = getClassLoader().getResource(packageName.replace(<span class="string">"."</span>,<span class="string">"/"</span>));</span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取项目路径失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果是文件则开始加载类并返回包含Class的Set</span></span><br><span class="line">            <span class="keyword">if</span>(url.getProtocol().equals(<span class="string">"file"</span>))&#123;</span><br><span class="line">                <span class="comment">//获取到项目路径下的文件</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(url.getFile());</span><br><span class="line">                <span class="comment">//同时获取项目路径</span></span><br><span class="line">                Path packagePath = file.toPath();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用nio的文件遍历项目路径</span></span><br><span class="line">                <span class="keyword">return</span> Files.walk(packagePath)</span><br><span class="line">                        <span class="comment">//使用过滤器来获取所有类文件</span></span><br><span class="line">                        .filter(path -&gt; path.toFile().getName().endsWith(<span class="string">".class"</span>))</span><br><span class="line">                        <span class="comment">//同时将所有的类文件调用加载并且存储</span></span><br><span class="line">                        .map(classPath -&gt; getClassByPath(classPath,packagePath,packageName))</span><br><span class="line">                        <span class="comment">//转化为Set集合</span></span><br><span class="line">                        .collect(Collectors.toSet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            log.error(<span class="string">"包加载失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"包加载异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将类注入一个接口，用于实现IOC</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Field field,Object target,Object value)</span></span>&#123;</span><br><span class="line">        setField(field,target,value,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setField</span><span class="params">(Field field,Object target,Object value,<span class="keyword">boolean</span> accessible)</span></span>&#123;</span><br><span class="line">        field.setAccessible(accessible);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            field.set(target,value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalAccessException e)&#123;</span><br><span class="line">            log.error(<span class="string">"注入属性失败"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"设置属性失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题笔记</title>
      <link href="/2020/03/06/other-algorithm/"/>
      <url>/2020/03/06/other-algorithm/</url>
      
        <content type="html"><![CDATA[<h3><span id="leetcode142环形链表">Leetcode.142：环形链表</span></h3><a id="more"></a><h4><span id="题目描述">题目描述：</span></h4><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><h4><span id="思路分析">思路分析</span></h4><p><strong>双指针法</strong></p><p>定义一个快指针，每次移动两步，定义一个慢指针，每次移动一步</p><p>当快慢指针同时为null，证明没有循环</p><p>当快指针和慢指针同时指向一处，证明链表中有环路，有循环</p><p>然后寻找循环的入口</p><p>设慢指针走了k步，则<br>f(slow) = k</p><p>快指针则走了<br>f(quick) = 2k</p><p>快指针比慢指针多走了若干个环路长度，设多走了n个环路长度，设环路长度为length，则</p><p>f(quick)  = k + n*length</p><p>可得k = n*length</p><p>代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode quick = head,slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(quick != <span class="keyword">null</span>)&#123;</span><br><span class="line">                quick = quick.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(quick != <span class="keyword">null</span>)&#123;</span><br><span class="line">                quick = quick.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(quick == slow &amp;&amp; quick != <span class="keyword">null</span> &amp;&amp; quick != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(quick == <span class="keyword">null</span> &amp;&amp; slow == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quick = head;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(slow == quick)&#123;</span><br><span class="line">                <span class="comment">//System.out.println(pos);</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos ++;</span><br><span class="line">                quick = quick.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(pos);</span><br><span class="line">        <span class="keyword">return</span> quick;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>哈希表法</strong></p><p>定义一个哈希set，把访问过的节点装进去</p><h3><span id="路径总和leetcode437">路径总和，leetcode.437</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定一个二叉树，它的每个结点都存放着一个整数值。</p><p>找出路径和等于给定数值的路径总数。</p><p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数</p><h4><span id="解题思路">解题思路</span></h4><p>在每一个树节点上进行递归搜索，查找所有符合情况的序列。</p><p>由于需要在每一个节点搜索，同时搜索也是递归搜索，所以是双重递归搜索</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        preTranver(root,sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preTranver</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        search(root,sum);</span><br><span class="line">        preTranver(root.left,sum);</span><br><span class="line">        preTranver(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum - root.val == <span class="number">0</span>)&#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="comment">//return ;</span></span><br><span class="line">        &#125;</span><br><span class="line">        search(root.left,sum - root.val);</span><br><span class="line">        search(root.right,sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="岛屿数量leetcode200">岛屿数量,leetcode.200</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><h4><span id="解题思路">解题思路</span></h4><p>要有污染的思路，从一个矩阵点开始进行污染，将所相连的所有陆地全部污染为海洋，函数定义一个污染深度，只有当污染深度为0的时候，才将岛屿计数器+1；</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] ma;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        ma = grid;</span><br><span class="line">        <span class="keyword">if</span>(grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>;row &lt; grid.length;row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>;col &lt; grid[<span class="number">0</span>].length;col++)&#123;</span><br><span class="line">                polute(row,col,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">polute</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> depth)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= ma.length || col &gt;= ma[<span class="number">0</span>].length || ma[row][col] == <span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            ma[row][col] = <span class="string">'0'</span>;</span><br><span class="line">            polute(row - <span class="number">1</span>,col,depth + <span class="number">1</span>);</span><br><span class="line">            polute(row + <span class="number">1</span>,col,depth + <span class="number">1</span>);</span><br><span class="line">            polute(row,col - <span class="number">1</span>,depth + <span class="number">1</span>);</span><br><span class="line">            polute(row,col + <span class="number">1</span>,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="leetcode945使数组唯一的最小增量">LeetCode.945.使数组唯一的最小增量</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p><p>返回使 A 中的每个值都是唯一的最少操作次数。</p><h4><span id="题目思路">题目思路</span></h4><p>学来的思路，线性探测和路径压缩，刚开始并没有想到路径压缩的方式。</p><p>首先需要一个可以把本题看成是一个hash表，如果为空，则将其插入，如果不为空，则看在该位置指出的下一个可插入的点，将其搜寻过的所有位置都置为最后插入的位置的坐标，该处需要递归实现。</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明开放线性搜寻函数</span></span><br><span class="line">    <span class="keyword">int</span>[] line = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(line,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">0</span>;temp &lt; A.length;temp ++)&#123;</span><br><span class="line">            <span class="comment">//最后插入的位置减去该值，就是最后需要移动的次数</span></span><br><span class="line">            res += findPos(A[temp]) - A[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//搜寻函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPos</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果该位置没有被插入，则直接插入</span></span><br><span class="line">        <span class="keyword">if</span>(line[val] == -<span class="number">1</span>)&#123;</span><br><span class="line">            line[val] = val;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果被插入过了，则搜寻该节点内存储的数据（即从该位置到数据中存储的位置之间，所有的节点都已经被占据）指向的最后位置的下一个位置是否位空，递归实现</span></span><br><span class="line">        <span class="keyword">int</span> resLocal = findPos(line[val]+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将该位置的值，设置为最后插入的位置，证明中间节点全部为，被占据的</span></span><br><span class="line">        line[val] = resLocal;</span><br><span class="line">        <span class="comment">//返回最后插入的位置</span></span><br><span class="line">        <span class="keyword">return</span> resLocal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="leetcode-820单词的压缩编码">leetcode 820,单词的压缩编码</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定一个单词列表，我们将这个列表编码成一个索引字符串 S 与一个索引列表 A。</p><p>例如，如果这个列表是 [“time”, “me”, “bell”]，我们就可以将其表示为 S = “time#bell#” 和 indexes = [0, 2, 5]。</p><p>对于每一个索引，我们可以通过从字符串 S 中索引的位置开始读取字符串，直到 “#” 结束，来恢复我们之前的单词列表。</p><p>那么成功对给定单词列表进行编码的最小字符串长度是多少呢？</p><h4><span id="解题思路">解题思路</span></h4><p>这题有点难，上来其实没有什么思路，看一下题目，其实他并不是完全压缩的字符串，由于结束字符的存在，他实际上只能是压缩每个单词的后缀，当单词存在前缀和中间相同的时候他其实并不能被压缩。</p><p>所以第一时间想到的方法其实是集合检测，简单来说，就是先把所有的单词放入集合中，然后对每个单词进行遍历，检查其后缀是否在集合中出现。如果出现了就将其删除。</p><p>官方给出了字典树的实现方式，其实更优，时间复杂度基本要降低一个数量级。但是由于并不是自己想出来的，所以就不给出解答。</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">0</span>;temp &lt; words.length;temp++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(words[temp]))&#123;</span><br><span class="line">                set.add(words[temp]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span>(String side : words)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">1</span>;temp &lt; side.length();temp++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(side.substring(temp)))&#123;</span><br><span class="line">                    set.remove(side.substring(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String side:set)&#123;</span><br><span class="line">            res += side.length()+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java单例模式</title>
      <link href="/2020/03/04/java-Singleton/"/>
      <url>/2020/03/04/java-Singleton/</url>
      
        <content type="html"><![CDATA[<p>单例模式实际上很好理解，在一个Java程序中只有一个该Java对象，从头到尾这个对象只被实例化一次。这样就防止了对象被频繁的创建和销毁。</p><a id="more"></a><p>在实际应用中，Spring的对象实际上都是单例，所以很有可能出现线程不安全的操作，比如说在controller里使用属性变量，在并发的时候就可能出现线程不安全的操作。</p><p>为了实现单例模式，就必须将这个对象的构造方法私有化，否则其他的地方也可以获取这个对象就不再是单例模式了。</p><p>那如何获取到这个对象的实例呢，内部提供一个获取该对象的接口，通过这个接口来获取对象。</p><h3><span id="单例模式例子">单例模式例子</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//直接在类的加载阶段就实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化该对象的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在其他函数中调用这个静态方法获取对象就可以了。</p><h2><span id="单例模式不同的实现方式">单例模式不同的实现方式</span></h2><p>单例模式有多种实现方式，拿出来一部分进行讲解。</p><h3><span id="懒汉式线程不安全实现">懒汉式线程不安全实现</span></h3><p>懒汉式线程不安全实现式最简单的实现方式之一，为什么叫懒汉式，因为在创建对象的时候并没有在创建的时候立刻将单例实例化，而是在第一次调用的时候才进行的实例化，所以在并发的时候就有可能出现线程不安全的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化该对象的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance =  = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="懒汉式线程安全实现">懒汉式线程安全实现</span></h3><p>只需要在原有的基础上将获取实例的方法进行同步化操作即可。但是效率太低，大部分的时候都不需要对方法进行同步。</p><p>优点是不会浪费空间，只有在第一次使用时才实例化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化该对象的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance =  = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="饿汉式实现">饿汉式实现</span></h3><p>饿汉式的意思就是这个人非常着急，等不到第一次使用才实例化，在类加载时就要把单例加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//直接在类的加载阶段就实例化一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化该对象的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式实现，效率很高，不用加锁，但是容易产生垃圾对象。在多种情况下都有可能出现类的加载，浪费空间。</p><h3><span id="双重校验锁">双重校验锁</span></h3><p>双重校验锁是线程安全懒汉式实现的优化，大幅度提高性能。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//私有化该对象的构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一来，只有在并发的且实例未创建的时候才进入同步代码块，其他时候直接就可以获取到实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java代理(proxy)模式</title>
      <link href="/2020/03/04/java-proxy/"/>
      <url>/2020/03/04/java-proxy/</url>
      
        <content type="html"><![CDATA[<p>首先说我认为代理模式的功能和作用，在需要访问某个对象的时候，如果要对这个对象进行操作，但是不能进行直接操作（比如数据处理，格式标准化）的时候，就可以使用代理模式，在不改变原有对象的情况下，扩展该对象的功能。</p><a id="more"></a><p>在代理模式中，有三个角色：抽象角色，真实角色，代理角色。</p><p>抽象角色定义了真实角色和代理角色要实现的方法。</p><p>真实角色是具体业务的实现逻辑。</p><p>代理角色对真实角色的逻辑处理，实现抽线角色中的方法，并在真实角色的基础上加上自己的操作，也就是扩展。</p><p>代理也有两种，一种是静态代理，一种是动态代理。</p><h3><span id="静态代理">静态代理</span></h3><p>静态代理模式：</p><p>抽象角色：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SearchService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>真实角色：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchServiceImpl</span> <span class="keyword">implements</span> <span class="title">SearchService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"searching now"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理角色：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchServiceProxy</span> <span class="keyword">implements</span> <span class="title">SearchService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SearchService searchService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchServiceProxy</span><span class="params">(SearchService searchService)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.searchService = searchService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理运行中"</span>);</span><br><span class="line">        System.out.println(<span class="string">"检测search运行环境"</span>);</span><br><span class="line">        <span class="keyword">return</span> searchService.search();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SearchServiceProxy proxy = <span class="keyword">new</span> SearchServiceProxy(<span class="keyword">new</span> SearchServiceImpl());</span><br><span class="line">        proxy.search(<span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">"代理测试完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态代理在不修改真实角色的情况下，扩展了真实角色的方法功能。</p><p>不足之处在于静态代理实现了所有抽象角色的方法，一旦接口发生改动，代理角色和真实角色的代码都要进行修改。</p><h2><span id="动态代理">动态代理</span></h2><p>动态代理有两种，一种是JDK代理，还有一种Cglib代理。</p><h3><span id="jdk动态代理">JDK动态代理</span></h3><p>为了解决静态代理时必须实现接口所有方法的问题，java提供了一个动态代理的类。</p><p>首先是代理不再需要实现接口了，Proxy对象利用JDK的apo在JVM内存中动态构建Proxy对象。</p><p>要使用到的就是Proxy类的newProxyInstance()方法，</p><p>该方法有三个参数：</p><ol><li>参数一，ClassLoader，需要指定类的加载器</li><li>参数二，Class&lt;?&gt; interface: 指定动态代理类需要实现的所有接口</li><li>参数三，InvocationHandler,得到实现InvocationHandler接口的子类</li></ol><p>发现了这个InvocationHandler接口，我们所以需要实现该接口，然它称为动态代理的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchServiceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchServiceHandler</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method method,Object[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理运行中"</span>);</span><br><span class="line">        System.out.println(<span class="string">"检测search运行环境"</span>);</span><br><span class="line">        Integer res = method.invoke(target,args)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装结束后，我们可以再将创建动态代理的接口newProxyInstance()的接口封装起来，让他成为一个工厂类。然后我们只要调用其中的方法就能获取到代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SearchServiceProxyFactory</span><span class="params">(Object target,InvocationHandler invocationHandler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.invocationHandler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterface(),</span><br><span class="line">            invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行入口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SearchServiceImpl target = <span class="keyword">new</span> SearchServiceImpl();</span><br><span class="line">        SearchServiceHandler handler = <span class="keyword">new</span> SearchServiceHandler(target);</span><br><span class="line">        ProxyFactory searchServiceProxyFactory = <span class="keyword">new</span> ProxyFactory(target,handler);</span><br><span class="line">        SearchService searchProxy = (SearchService)searchServiceProxyFactory.getProxy();</span><br><span class="line">        System.out.println(searchProxy.search());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="cglib动态代理">CGLIB动态代理</span></h3><p>CGLIB动态代理方式是对JDK提供的代理方式的补充，JDK动态代理必须要求目标类是某个接口的实现，所以CGLIB补充了这个不足,可以代理一个没有实现任何接口的类。</p><p>但是使用时需要用maven引入jar包</p><p>比如我们直接生成真实角色。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">weakUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我醒了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span></span>&#123;  </span><br><span class="line">        enhancer.setSuperclass(clazz);  </span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);  </span><br><span class="line">        <span class="keyword">return</span> enhancer.create();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 拦截所有目标类方法的调用 </span></span><br><span class="line"><span class="comment">     * 参数： </span></span><br><span class="line"><span class="comment">     * obj  目标实例对象 </span></span><br><span class="line"><span class="comment">     * method 目标方法的反射对象 </span></span><br><span class="line"><span class="comment">     * args 方法的参数 </span></span><br><span class="line"><span class="comment">     * proxy 代理类的实例 </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args,  </span></span></span><br><span class="line"><span class="function"><span class="params">            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">        <span class="comment">//代理类调用父类的方法  </span></span><br><span class="line">        System.out.println(<span class="string">"我准备醒来"</span>);  </span><br><span class="line">        proxy.invokeSuper(obj, args);  </span><br><span class="line">        System.out.println(<span class="string">"我又睡下了"</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入口类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        CGLibProxy proxy = <span class="keyword">new</span> CGLibProxy();  </span><br><span class="line">        Person t = (Persion) proxy.getProxy(Person<span class="class">.<span class="keyword">class</span>)</span>;  </span><br><span class="line">        t.weakUp();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程与并发(3)</title>
      <link href="/2020/03/03/java-concurrent3/"/>
      <url>/2020/03/03/java-concurrent3/</url>
      
        <content type="html"><![CDATA[<h1><span id="atomicinteger">AtomicInteger</span></h1><p>前面使用volatile关键字虽然能保证线程之间的可见性，但是当出现 i++ 这样的操作，这样的复合操作无法保证其并发时数据的正确性。所以java中实现了Atomic包来保证部分操作的原子性。</p><p>我们这里就采用AtomicInteger来分析。</p><h2><span id="底层存储使用的一些变量">底层存储使用的一些变量</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, "value");</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>我们依然可以在这里发现Unsafe类，这里一样使用了CAS来保证多线程并发时的数据一致性。</p><h2><span id="atomic实现的部分方法">Atomic实现的部分方法</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndSetInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法以原子的方式写入新的值，再将原来的值返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSetInt(<span class="keyword">this</span>, VALUE, expectedValue, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用CAS的方式设置新的值，检测现在的值是否符合预期值，如果符合再将新的值写入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>, VALUE, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先自增一次，再将返回之后的值。类似和方法还有getAndIncrement则是先获取，再自增。</p><p>所以分析该包的核心防止并发数据不一致的方法时CAS。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>computer-network</title>
      <link href="/2020/02/23/computer-network/"/>
      <url>/2020/02/23/computer-network/</url>
      
        <content type="html"><![CDATA[<h1><span id="传输层协议分析">传输层协议分析</span></h1><a id="more"></a><h2><span id="tcp与udp协议的对比特点">TCP与UDP协议的对比特点</span></h2><p>TCP协议是有连接的协议，面向字节流，报文有顺序，拥有流量控制，拥塞控制。只能一对一点对点的传输。</p><p>而UDP协议是无连接的协议，面向报文，报文没有顺序。没有流量和拥塞控制。可以一对一，一对多，多对多，多对一传输。</p><h2><span id="tcp三次握手建立连接">TCP三次握手建立连接</span></h2><p>TCP通过三次握手建立连接。</p><p>S1. 服务器端监听，等待客户端的连接请求。</p><p>S2. 客户端向服务器端发送请求连接报文，SYN = 1, ACK = 0，同时设置初始序列号x</p><p>S3. 服务端收到请求报文，如果同意建立连接，则向A发送确认连接报文SYN = 1,ACK = 1,确认号为x + 1,同时设置一个初始序列号y。</p><p>S4. 客户端收到服务端报文，向客户端发送确认报文，确认号为y + 1，序列号为x + 1</p><p>S5. 服务端收到客户端的收到确认的报文，连接建立。</p><p>三次握手实际上是为了方式失效的连接请求到达服务器，然后服务器错误的打开连接。</p><h2><span id="tcp四次挥手">TCP四次挥手</span></h2><p>S1. 客户端发送连接释放报文，FIN = 1。</p><p>S2. 服务端收到后发出确认报文，此时TCP连接时半关闭状态，服务端能单向给客户端发送数据。客户端进入CLOSE_WAIT状态。</p><p>S3. 当服务端决定释放连接时，向客户端发送释放报文，FIN = 1</p><p>S4. 客户端收到后向服务端发送确认报文，进入TIME-WAIT状态，等待报文最大存活时间后释放连接。</p><p>当服务端收到确认后彻底释放连接。</p><p>四次挥手的目的是为了让服务端发送完剩下的所有数据，当数据传输结束，就会释放报文。</p><h2><span id="tcp滑动窗口">TCP滑动窗口</span></h2><p>窗口用来作为缓存，暂时存放字节流，发送方和接收方都各有一个滑动窗口。</p><p>接收方使用TCP报文告诉发送方自己的窗口大小，发送方再根据这个值和其他信息设置自己的窗口大小。</p><p>对于发送方来说，在窗口内的数据字节都允许被发送。发送窗口的有两部分，左边的部分是已经发送了的还没有得到确认的数据，右边的是还未发送的数据。当发送方收到接收方对左部数据的确认，则将窗口向右滑动直到第一个自己不是已发送且确认的状态。</p><p>对于接收方，滑动窗口的左部是已经确认而未交付到主机的字节，而右侧是还未确认的数据。当右侧数据被交付到主机，窗口就向右滑动直到第一个字节不是以及交付主机的位置。</p><p>接收窗口只会对按序到达的最后一个字节进行确认，比如收到的字节为[1,2,3,4,7,8],那么接收方只会发送对4的确认，这样发送方就直到4及其之前的数据都被接收了。</p><h2><span id="tcp流量控制">TCP流量控制</span></h2><p>流量控制是为了控制发送方速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送发窗口大小，从而影响发送方的发送速率。当窗口字段为0，发送方则不能发送数据。</p><h2><span id="tcp拥塞控制">TCP拥塞控制</span></h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续传送，导致网络拥塞程度继续增加。因此出现拥塞的时候，应当控制发送方的速率。这点有点像流量控制，但是目的不同，流量控制为了接收方来得及接收，拥塞控制为了降低整个网络的拥塞程度。</p><p>TCP主要通过4个方法来进行拥塞控制，慢启动，拥塞避免，快重传和快恢复。</p><p>发送方需要维护一个拥塞窗口的状态变量(cwnd),注意拥塞窗口只是一个状态变量，实际决定能发送多少数据的是发送方窗口。</p>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程与并发(2)</title>
      <link href="/2020/02/19/java-concurrent2/"/>
      <url>/2020/02/19/java-concurrent2/</url>
      
        <content type="html"><![CDATA[<h1><span id="多线程并发二">多线程并发(二)</span></h1><a id="more"></a><h2><span id="线程间通信的方法">线程间通信的方法</span></h2><p>进程间通信的常用方法在java中有这么三种：</p><p>这三种方法都必须在同步代码块或者同步方法中。</p><ol><li><p>wait()<br>当该方法执行时，当前线程进入阻塞状态，并且释放同步监视器(也就是所持有的锁)</p></li><li><p>notify()<br>当此方法执行，就会唤醒一个被wait的线程。如果有多个线程处于wait状态，就唤醒优先级高的线程，(唤醒的该锁阻塞的其他线程)。</p></li><li><p>notifyAll()<br>当执行此方法，就会唤醒所有处于wait情况的线程。</p></li></ol><p>如果我们搞明白了线程间通信的三种方法，那么使用这三种方法，来实现在操作系统中典型的线程间通信案例，生产者和消费者案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者和消费者案例</span></span><br><span class="line"><span class="comment">//要注意，创建线程时需要使用同一个对象来创建线程，以保证同步方法有效化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="comment">//当货物缓冲区满时，停止生产，线程阻塞</span></span><br><span class="line">        <span class="comment">//使用while，防止过度生产，过度消费</span></span><br><span class="line">        <span class="keyword">while</span>(buffer.isFull())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当阻塞线程被唤醒，开始生产，或者货物缓冲区不满的时候</span></span><br><span class="line">        buffer.incr();</span><br><span class="line">        <span class="comment">//唤醒消费者线程，这里唤醒其余所有线程的原因是防止唤醒顺序出现异常而进入死锁状态</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(buffer.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.decr();</span><br><span class="line">        notifyAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>sleep()和wait()有什么区别</p><p>sleep()在阻塞的时候不会释放其拥有的锁，而wait会释放.</p></blockquote><h2><span id="volatile关键字">volatile关键字</span></h2><p>在前面提到了JMM模型，其中提到的可见性问题，Java提供了volatile关键字来解决，使用volatile关键字修饰后，就可以保证该对象/变量在各个线程之间的可见性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>线程之间的可见性代表了什么，实际上就相当于将对变量的修改将会立即写入主存中，其他线程可以在某个线程修改值了之后立刻发现他的改变。在原有的JMM中，因为有本地内存的概念，对变量的修改实际上并不能立刻写回到主存中。这是volatile关键字的一种功能。</p><p><img src="/img/JMM.jpeg" alt="JMM"></p><p>还有一种是volatile可以禁止指令进行重排序。在前面提到，JVM为了高效执行指令，会对指令进行一部分的重排序。volatile就可以禁止这部分指令重排序，从而保证各个线程读取到的都是最新的正确的值。</p><p><img src="/img/volatile.jpeg" alt="volatile"></p><p>被volatile修饰的变量本身具有以下特性。</p><ul><li>可见性，也就是上面提到的。</li><li>原子性，对于volatile修饰的变量，赋值操作和读取操作(读写操作)都是原子的。</li></ul><p>volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><p>volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>而实际上，为了禁止重排序，在前面也提到了一种内存屏障的技术。</p><p>volatile内存语义的实现——JMM对volatile的内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>所以在一定程度上，volatile保证了有序性。</p><p>但是关于<strong>原子性</strong>，虽然读写操作是原子性的，但是比如val++,或者是x = x + 1这种操作并非原子操作，他们复合了读写，并不能保证其原子性。</p><h1><span id="各种锁的实现与概念">各种锁的实现与概念</span></h1><h2><span id="1可重入锁">1.可重入锁</span></h2><p>可重入锁，又被称为递归锁，描述的是一种，如果外层方法已经获取到了一把锁，那么内层方法再次尝试获取这把锁的时候，就可以直接获取到，而不是陷入阻塞。</p><p>常见的可重入锁比如：synchronized，ReentrantLock，都符合该种锁的特征。</p><p>可重入锁的实现方式一般如下：</p><p>锁的状态由0~n构成，当0时表示没有线程获取到这把锁，当大于0时则有线程获取这把锁。</p><p>当外层方法获取到这把锁时，将锁状态从0增长为1，代表有一层方法获取到了这把锁。</p><p>当内层方法再次获取时，发现同一线程的外层方法已经获取到锁了，在同一线程内部自然不存在并发问题，所以该只需要将锁状态在加一，表明又有一层方法获取到了锁即可。</p><p>当锁释放时，自然时从里层到外层依次减一，知道该线程所有获取到的锁都被释放，该锁状态重新回到0，其他线程才可以再次获取到这把锁。</p><h2><span id="公平锁和非公平锁">公平锁和非公平锁</span></h2><p>synchronized关键字在jvm层面实现，而且实际上并不是公平锁，所以在Lock中又对公平锁进行了实现，比如ReentrantLock就可以实现公平锁，但是ReentrantLock是默认实现非公平锁的。</p><p>什么是公平锁呢，公平锁就是：</p><blockquote><p>当一个线程尝试获取锁，如果此时锁被其他人占用，则直接进入队列。各个线程对锁的占用则是按照队列依次进行。公平锁的好处则是每个线程都不会被饿死，每个线程都会获取到锁并执行。</p></blockquote><p>而非公平锁则是：</p><blockquote><p>非公平锁则是可以被插队的。当线程尝试获取锁的时候，有两种可能：</p><ol><li><p>当时其他线程正在工作，根本无法获取锁，那么就加入队列。</p></li><li><p>当时其他线程刚好工作完成，队列还没有给下一个队列中任务分配锁，那么这时候这个尝试获取锁的线程就会插队，到队列之前先获取到锁，从而直接开始工作。</p></li></ol></blockquote><p>既然ReentrantLock中有公平锁和非公平锁的实现，我们就拿出来看看是怎么实现的。</p><p>先来看默认的非公平机制是怎么实现的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取当前线程状态，用于实现可重入操作，说明的是当前重入的次数</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当这个线程没有获得任何锁的时候进行处理，使用CAS的方式获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">//设置获取锁的线程，也就是线程第一次获取锁，打上标记</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="comment">//返回获取锁成功，第一次为非重入</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//如果此时为重入时的操作</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">//重入层数增加</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">//设置新的重入层数</span></span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="comment">//返回获取锁成功，为重入</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>再看看公平锁的实现方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取重入状态</span></span><br><span class="line">    <span class="comment">//如果时第一次获取</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//仅仅在这里和非公平锁不同，这里hasQueuedPredecessors()方法的功能是检测当前线程是不是同步队列中的第一个，正是这里保证了是否公平，如果第一个节点不是当前线程则返回true，是当前线程则返回false，在加上!符号，就完成了不能插队的操作</span></span><br><span class="line">       <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>唯一的不同我已经在文章中标注出来。</p><h2><span id="自旋锁">自旋锁</span></h2><p>自旋锁就是一种特殊的锁形式，当一个线程是自旋锁的时候，就会不断反复尝试获取到这个锁，直到获取到为止。</p><p>而非自旋锁则是当尝试获取不到这个锁，则进入阻塞态，直到其他线程将其唤醒。这个过程中的阻塞和唤醒恢复十分消耗性能，对于少量代码使用非自旋的方式是一种得不偿失的行为。</p><h1><span id="线程池">线程池</span></h1><p>线程的创建和销毁是十分消耗性能的，为了降低创建和销毁线程对性能的消耗t，就可以使用线程池。需要使用的时候从线程池中提取，使用结束再将其释放回线程池。重复使用线程，降低消耗。</p><h2><span id="threadpoolexecutor线程池类参数解析">ThreadPoolExecutor线程池类参数解析</span></h2><table><thead><tr><th>参数</th><th>参数含义</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数量，线程池维护线程的最小数量</td></tr><tr><td>maximumPoolSize</td><td>线程池维护线程的最大数量</td></tr><tr><td>keepAliveTime</td><td>线程池除去核心线程外，其他线程的最长空闲事件，超过空闲时间的线程将会被销毁</td></tr><tr><td>unit</td><td>keepAliveTime的单位，TimeUnit里的几个静态属性</td></tr><tr><td>workQueue</td><td>线程池使用的任务缓冲队列</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建线程，一般使用默认的即可</td></tr><tr><td>handler</td><td>线程池对拒绝任务的处理策略</td></tr></tbody></table><p>这里ThreadPoolExecutor提供了四种策略：</p><ul><li>AbortPolicy:丢弃任务并抛出RejectedExecutionExeption异常</li><li>DiscardPolicy:丢弃任务，且不抛出异常</li><li>DiscardOldestPolicy:丢弃队列最前面的任务，然后重新尝试执行任务</li><li>CallerRunsPolicy:调用线程处理该任务<br>可以通过实现RejectedExecutionHandler接口自定义处理方式</li></ul><h2><span id="线程池任务执行">线程池任务执行</span></h2><h3><span id="1-添加执行任务">1. 添加执行任务</span></h3><ul><li>submit()该方法返回一个Future对象，可执行代返回值的线程；或者执行随时可以取消的线程。Future对象的get()方法获取返回值，cancel(true/false)取消任务，未开始活已完成返回false，参数表示是否中断执行中的线程。</li></ul><table><thead><tr><th>提交方式</th><th>是否关心返回结果</th></tr></thead><tbody><tr><td>Future<t> submit(Callable<t> task)</t></t></td><td>关心</td></tr><tr><td>void execute(Runnable command)</td><td>不关系</td></tr><tr><td>Future&lt;?&gt; submit(Runnable task)</td><td>不关系，虽然返回了future对象，但是get()方法总是null</td></tr></tbody></table><h3><span id="2-线程池提交任务的过程">2. 线程池提交任务的过程</span></h3><ol><li>如果线程池中线程的数量小于corePoolSize，即使所有的线程都是空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果线程数等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。</li><li>如果大于等于corePoolSize，缓冲队列已满，且线程池中线程的数量小于maximumPoolSize，则创建新线程来处理新任务。</li><li>如果大于core线程且缓冲队列满，同时最大线程数也等于当前线程数，那么通过handler指定的策略来处理此任务。</li><li>线程数大于corePoolSize，将会根据keepAliveTime来动态调整线程池中的线程。</li></ol><h3><span id="3-线程池关闭">3. 线程池关闭</span></h3><ul><li>shutdown() 不接受新任务，会处理已经添加了的任务</li><li>shutdownNow() 不接收新任务，也不处理添加了的任务，正在处理中的任务也将中断。</li></ul><h3><span id="4-常用的阻塞队列">4. 常用的阻塞队列</span></h3><ol><li>ArrayBlockingQueue 一个由数组实现的的容量固定的有界阻塞队列</li><li>SynchronousQueue 没有容量，不能缓存数据；每个put必须等待一个take。</li><li>LinkedBlockQueue 是一个由链表实现的无界阻塞队列。它也提供了一个可选的有界构造函数。在未指明容量时，默认容量未Interger.MAX_VALUE.</li></ol><p>队列的常用操作</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>add</td><td>增加一个元素；如果队列已满，则抛出一个异常</td></tr><tr><td>remove</td><td>移除并返回队列头部的元素；如果队列为空，则抛出一个异常</td></tr><tr><td>offer</td><td>添加一个元素并返回true；如果队列已满则返回false</td></tr><tr><td>poll</td><td>移除并返回队列头部的元素，如果队列为空，则返回null</td></tr><tr><td>put</td><td>添加一个元素，如果队列满，则阻塞</td></tr><tr><td>take</td><td>移除并返回队列头部的元素，如果队列为空，则阻塞</td></tr><tr><td>element</td><td>返回队列头部的元素，如果队列为空，则抛出一个异常</td></tr><tr><td>peek</td><td>返回队列头部的元素，如果队列为空，则返回null</td></tr></tbody></table><p>实际上这些操作方式就是队列常用的操作在外加阻塞式实现。</p><h3><span id="executors线程工厂类">Executors线程工厂类</span></h3><p>线程工厂类用于产生一个固定特性的线程池。</p><h4><span id="1-executorsnewcachedthreadpool">1. Executors.newCachedThreadPool()</span></h4><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.</p><h4><span id="2-executorsnewfixedthreadpoolint">2. Executors.newFixedThreadPool(int)</span></h4><p>创建一个定长线程池，可控制线程的最大并发数，超出的线程会在队列中等待</p><h4><span id="3-executorsnewsinglethreadexecutor">3. Executors.newSingleThreadExecutor()</span></h4><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照顺序执行</p><h4><span id="4-executorsnewscheduledthreadpoolint">4. Executors.newScheduledThreadPool(int)</span></h4><p>创建一个支持定时周期性任务的线程池。</p><h2><span id="线程池的使用案例">线程池的使用案例</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadId;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskThread</span><span class="params">(<span class="keyword">int</span> threadId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadId = threadId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Task "</span>+ threadId + <span class="string">" is working"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"Task "</span>+ threadId + <span class="string">" has finished"</span>);        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="合理配置线程池">合理配置线程池</span></h2><p>关于线程池中的corePoolSize参数，需要根据不同的情况来设置比较优化的值。</p><h3><span id="cpu密集型">CPU密集型</span></h3><p>CPU密集型指的是任务需要大量的运算，阻塞比较少，CPU全速运行。</p><p>CPU密集型任务只有在真多核CPU上才能得到加速。</p><p>CPU密集型的任务尽可能的少配置线程数。</p><p>一般数量为：CPU核数+1</p><h3><span id="io密集型">IO密集型</span></h3><p>IO密集型的程序常常需要阻塞来为IO开道，所有尽可能的配置多的线程数，比如：CPU核数*2</p><p>或者：CPU核数/(1-阻塞系数)</p><h1><span id="threadlocal">ThreadLocal</span></h1><p>ThreadLocal是一种特殊的工具，它可以在使用多线程的时候，为每一条不同的线程提供一个独立的存储空间。也就是说，使用ThreadLocal创建的变量，在多线程并发的时候并不会出现其他线程改变本线程值的情况。</p><p>以下是代码实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestThread test1 = <span class="keyword">new</span> TestThread();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; localVal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> normal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Double d = Math.random()*<span class="number">10</span>;</span><br><span class="line">        normal = d.intValue();</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        localVal.set(d.intValue());</span><br><span class="line">        System.out.println(localVal.get()+<span class="string">" "</span>+ normal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>输出的结果为：3 7，7 7，3 7。说明虽然并发执行，但是传统变量并没有自己的一份本地副本，并发执行的时候只能读取当前公用变量的值。</p></blockquote><h2><span id="threadlocal-使用注意事项">ThreadLocal 使用注意事项</span></h2><p>分析源码可知，在ThreadLocal内部，底层实现的方式其实是一个Map，用来存储每个线程对应映射的val值，而在这里出现了一次弱引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>弱引用只能存活到下一次GC之前，所以有可能线程还未结束，该map的key值就已经因为GC而失效了。然而其他位置依然对整个Map有引用，所以value并不会失效，但是无法访问到该value了。这就产生了内存泄漏。</p><blockquote><p>内存泄漏就是指内存申请了却无法释放，当泄漏的太多就会产生内存溢出。</p></blockquote><p>为了防止内存泄漏，就需要在不再使用ThreadLocal线程的最后调用一次set(),remove(),get()方法，这些方法的最后都有释放内存的操作。</p><h1><span id="blockingqueue">BlockingQueue</span></h1><p>实现该接口的都是线程安全队列，就和他的中文释义一样，阻塞队列。</p><h2><span id="1-arrayblockqueue">1. ArrayBlockQueue</span></h2><p>分析其底层数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得元素的下标索引</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放元素的下标索引</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中元素的数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于控制并发访问的重入锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于在重入锁中实现线程等待和唤醒的，取元素的等待情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放元素的等待情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure></p><p>可以在底层数据结构中发现重入锁ReentranLock的影子，所以该阻塞队列是使用重入锁来实现线程安全的。</p><h3><span id="底层方法分析">底层方法分析</span></h3><p>构造器方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法实质上是真正启动的构造器方法，它分配了有限的队列空间，同时对锁相关的变量进行初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用该构造器，可以将继承Collection接口的数据直接转化为阻塞队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(capacity, fair);</span><br><span class="line">    <span class="comment">//在开始初始化之间获取锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//给线程加锁</span></span><br><span class="line">    lock.lock(); <span class="comment">// Lock only for visibility, not mutual exclusion</span></span><br><span class="line">    <span class="comment">//开始进行初始化</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (E e : c)</span><br><span class="line">                items[i++] = Objects.requireNonNull(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        count = i;</span><br><span class="line">        putIndex = (i == capacity) ? <span class="number">0</span> : i;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//放入元素时</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查是否值为空</span></span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="comment">//获取当前锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//如果当前线程没有中断，锁定当前线程。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查队列是否已经满了，如果满了，就让让线程阻塞，将锁释放</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//阻塞被唤醒后将数据添加入队列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//最后将锁释放</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = e;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length) putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总的来说，ArrayBlockingQueue就是通过重入锁，来实现并发访问控制的。</p><h2><span id="2-linkedblockingqueue">2. LinkedBlockingQueue</span></h2><p>LinkedBlockingQueue实际上和ArrayBlockingQueue相似，但是在链式实现中却发现这里使用了两把锁来进行工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列头部拿取元素调用的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拿取元素对应的，队列空时调用的condition变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列尾部添加元素时使用的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>使用两把锁的原因实际上是因为，链式结构中，队列头和队列尾的操作互不影响，使用两把锁可以降低并发粒度，同时操作队头队尾。</p><h1><span id="concurrenthashmap">ConcurrentHashMap</span></h1><p>ConcurrentHashMap作为并发包中最有代表性的存在，我们对其源码和部分方法进行解读。</p><p>该类的本质仍然是HashMap的一种，但其为线程安全，可以用于多线程编程的情况。</p><h2><span id="底层数据结构">底层数据结构</span></h2><p>它的底层数据结构与普通的HashMap相似，都是链表+红黑树的结构，不同的是，存储起始节点的数组被volatile关键字修饰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p><p>分析源码就可以发现，table数组的初始化实际上在第一次使用的时候才进行初始化。对初始化table数组的源码进行分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">//在这里每次循环，都要求tab是最新的table数组引用</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//sizeCtl是一个标记位，如果是-1，就代表已经有线程进行初始化工作了</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">//CAS操作，将该实例的sizeCtl变量设置为-1</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果操作成功，本线程就会开始负责初始化工作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//再次检查是否已经被初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//这里设定默认数组大小，为16</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">//给初始化的数组分配空间</span></span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">//将分配好的内存赋值给实例</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//这里通过位运算，相当于×0.75</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//将计算结束后的sc值赋给sizeCtl，表示到达12就进行扩容</span></span><br><span class="line">                <span class="comment">//由于这里已经确保只有一个线程在运行，可以直接赋值，因为sizeCtl被volatile修饰</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里实际上使用的几个并发编程的解决方法，一个是CAS，另一个是volatile变量。</p><h2><span id="部分数据集操作方法的分析">部分数据集操作方法的分析</span></h2><h3><span id="put方法">put方法</span></h3><p>接下来分析put方法的线程安全解决方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//当数据不为空合法的时候开始处理，首先计算源数据的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//一个无限循环，直到完成操作后手动break出循环</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//当table为被分配时，调用初始化方法</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">//这种情况下使用Unsafe类中的类volatile方法取出散列后通过运算的出的Node数组下标对应的对象，如果Node对象为空，则代表还没有线程对该Node进行插入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//以cas方式插入数据</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">                <span class="comment">//插入成功后退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看是否在扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock</span></span><br><span class="line">                 &amp;&amp; fh == hash</span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="keyword">null</span> &amp;&amp; key.equals(fk)))</span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> fv;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//准备开始加锁插入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">//再次确认对象是不是原来的那一个</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//无限循环，直到完成put操作</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//先比较hash，在比较equals</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//和链表头节点Node不冲突，就将其初始化为新Node作为上个节点的next</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果时树形态，则进入树形态的插入阶段</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在put方法中，出现了一个封装后的Unsafe查询操作，来进行类volatile的操作，类volatile的查看值。保证每次查询的值都是最新的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectAcquire(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用这种方式的原因时因为，table虽然加了volatile，但是只能保证其引用的可见性，并不能保证数组对象是最新的，所以需要这种方式来拿到最新的Node数据。</p><p>总的来说，对于put操作进行的加锁是在一条链上加锁。所以在Hash完美不冲突时，最多可以支持n哥线程同时进行put操作，n为node数组的大小。当hash冲突严重时，链表越来越长，次是会进行扩容，将Node数据重新散列。</p><p>这里使用了几种并发技巧：</p><ol><li>降低锁的粒度，这里对每一条不同位置的链表加锁，上锁只锁一条链表，就可以保证线程安全，最大程度上提高了并发度。</li><li>Unsafe方法的封装，确保值为最新。</li></ol><h3><span id="get方法">get方法</span></h3><p>如果是只读，并不会产生线程安全的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他操作都与普通的HashMap相似，但是这里使用了上面提到的封装好的tabAt方法来立刻读取内存内的数据。</p><h3><span id="多线程并发扩容方法">多线程并发扩容方法</span></h3><p>这是一个非常复杂的方法，同时也是非常有参考意义的一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSetInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSetInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM解析（三）</title>
      <link href="/2020/02/17/jvm-3/"/>
      <url>/2020/02/17/jvm-3/</url>
      
        <content type="html"><![CDATA[<h1><span id="classloader类加载机制">ClassLoader(类加载机制)</span></h1><a id="more"></a><p>类的加载并不是一次全部加载的，而是在使用时动态加载的。</p><h2><span id="类的生命周期">类的生命周期</span></h2><p>类的生命周期包括以下阶段：</p><ol><li>加载(Loading)</li><li>验证(Verification)</li><li>准备(Preparation)</li><li>解析(Resolution)</li><li>初始化(Initialization)</li><li>使用(Using)</li><li>卸载(Unloading)</li></ol><h2><span id="类加载过程">类加载过程</span></h2><h3><span id="1-加载">1. 加载</span></h3><p>该阶段会在内存中生成代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。</p><p>获取二进制字符流的方式有：</p><ol><li>从一个Class文件获取</li><li>从一个ZIP包中获取，比如jar</li><li>运行时计算产生，比如动态代理</li><li>由其他文件生成，比如jsp</li></ol><h3><span id="2-验证">2. 验证</span></h3><p>该阶段确保字节流中包含的信息符符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。</p><p>可以分成以下四个流程：</p><ol><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ol><h3><span id="3-准备">3. 准备</span></h3><p>正式为类变量(static修饰变量)分配内存，并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。实例变量不会再这个阶段分配内存，它将会在对象实例化时随着对象一起分配在Java堆中。</p><h3><span id="4-解析">4. 解析</span></h3><p>虚拟机将常量池中的符号引用替换为直接引用的过程。</p><blockquote><p>符号引用：就是class文件中的一部分CONSTANT变量，符号引用与虚拟机实现的布局无关，引用的目标并不一定已经加载到内存中。</p></blockquote><blockquote><p>直接引用：指向目标的指针，相对偏移量或者时一个内简介定位到目标的句柄。如果有直接引用，那目标在内存中必然已经存在。</p></blockquote><h3><span id="5-初始化">5. 初始化</span></h3><p>初始化阶段才开始正式执行类中负责定义的Java程序代码，虚拟机执行类构造器方法，对类的静态变量赋予正确的初始值，JVM负责对类开始进行初始化。</p><h2><span id="类加载加载器">类加载加载器</span></h2><p>类加载器有以下几种：</p><h3><span id="1-bootstrap-classloader">1. BootStrap ClassLoader</span></h3><p>启动类加载器，主要负责jdk_home/lib目录下的核心api或者x-bootclasspath指定的jar包的装入工作</p><h3><span id="2-extension-classloader">2. Extension ClassLoader</span></h3><p>扩展类加载器，主要负责jdk_home/lib/ext目录下的jar包，或者-<br>Djava.ext.dirs指定目录下的jar包装入工作。</p><h3><span id="3-system-classloader">3. System ClassLoader</span></h3><p>系统类加载器，主要负责java -classpath/Djava.class/path所指目录下的类和jar。</p><h3><span id="4-user-custom-classloader">4. User Custom ClassLoader</span></h3><p>用户自定义加载器，通过java.lang.classloader的子类动态加载。</p><h2><span id="双亲委派模式">双亲委派模式</span></h2><p>双亲委派工作模式是这样的：</p><p>如果一个类加载器收到类加载的请求，它首先不会自己去加载这个类，而是给父加载器去完成，依次向上，所以所有的类加载请求都应该被传递到顶层的启动类加载器，只有父加载器找不到所需类，子加载器才尝试加载该类。</p><p>双亲委派模式的好处如下：</p><ol><li><p>通过带有优先级的层级关可以避免类的重复加载，保证唯一性。</p></li><li><p>保证Java程序安全稳定运行，Java核心API定义类型不会被随意替换。</p></li></ol><h2><span id="获取类的对象的三种方式">获取类的对象的三种方式</span></h2><ol><li>类名.class,比如String.class</li><li>对象.getClass(),testString.getClass()</li><li>Class.forName(),比如Class.forName(“java.lang.String”)</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2020/02/17/redis-1/"/>
      <url>/2020/02/17/redis-1/</url>
      
        <content type="html"><![CDATA[<p>Redis是一个典型的NoSQL数据库。<br><a id="more"></a></p><h1><span id="redis的基本数据类型">Redis的基本数据类型</span></h1><table><thead><tr><th>数据类型</th><th>存储数据特性</th><th>可进行的操作</th></tr></thead><tbody><tr><td>String</td><td>字符串，整数，浮点数</td><td>对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作</td></tr><tr><td>set</td><td>无需集合</td><td>添加，获取，移除单个元素，检查一个元素是否存在集合中，交、并、差集合计算，从集合中随机获取元素</td></tr><tr><td>hash</td><td>包含键值对的无序散列表</td><td>添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td></tr><tr><td>list</td><td>列表</td><td>从两端压入或者弹出元素，对单个或者多个元素进行修建，指保留一个范围内的元素</td></tr><tr><td>zset</td><td>有序集合</td><td>添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td></tr></tbody></table><h1><span id="部分数据结构的底层实现">部分数据结构的底层实现</span></h1><h2><span id="string-的部分底层原理">String 的部分底层原理</span></h2><p>Redis底层String存储并非和C的存储方式完全一致，他使用了一个自己定义的结构体。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">//保存已经使用的字节长度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* 已经被分配的字节长度 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="comment">//字符数组，用于保存Stirng数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这样存储自然有这样存储的好处</p><h3><span id="1-获取字符串长度的操作为o1">1. 获取字符串长度的操作为O(1)</span></h3><p>因为字符串长度已经被保存在了结构体中，不需要再进行遍历操作。</p><h3><span id="2-不会造成缓冲区溢出">2. 不会造成缓冲区溢出</span></h3><p>Redis执行字符串扩展是会首先检查空余空间是否足够执行字符串扩展，如果不够，就会重新分配内存。</p><h3><span id="3-减少重新分配内存的次数">3. 减少重新分配内存的次数</span></h3><p>Redis预先分配一段额外内存用于扩展，减少重新申请内存的次数。</p><p>当字符串被删减的时候，多余的内存也并不会被自动回收。</p><h3><span id="4-二进制安全">4. 二进制安全</span></h3><p>在c程序中，字符串结束的标志是’\0’，而在redis中，由于字符串是否结束是由len决定的，所以可以存在一个字符串中间出现’\0’的情况。</p><h3><span id="5-兼容部分c的字符串函数">5. 兼容部分c的字符串函数</span></h3><h2><span id="list的底层实现">list的底层实现</span></h2><p>原本的ziplist在最新版的redis中被quicklist取代，同时在其中使用双端链表和ziplist。</p><p>首先是list本身：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* count表明当前list里有多少元素 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* 这个链表中节点的个数 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : <span class="number">16</span>;              <span class="comment">/* 单个节点的负载比例 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure></p><p>list本身由该结构体构成，而其中拥有list的节点，该结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//指向前一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">//指向后一个节点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">//指向实际的ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* 存储这个ziplist占用空间的大小，单位为字节 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* 有多少元素储存在这个节点的ziplist中 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2   编码方式*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 存储方式，默认为ziplist*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* 它表示当前的 quicklistNode 是不是已经被解压出来作临时使用? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure></p><p>可以分析出来，list本身是双向链表。</p><h1><span id="redis快的原因">Redis快的原因</span></h1><p>除去Redis的基本数据结构外，Redis为什么这么快呢？</p><ol><li><p>完全基于内存，绝大部分都是纯粹的内存操作。</p></li><li><p>数据结构简单，对数据的操作也简单，Redis的数据结构是专门进行设计的。</p></li><li><p>采用单线程，没有上下文切换和竞争条件，也没有线程切换的消耗，不用考虑大量的锁操作，更不可能产生死锁。</p></li></ol><blockquote><p>Redis为什么采用单线程呢？</p><p>Redis都是基于内存的操作，CPU并不是其瓶颈。如果单线程容易去实现，就采用单线程方案了。</p><p>有因为所有的操作都是单线程的，就保证了所有操作都是原子性的。</p></blockquote><ol start="4"><li>使用多路复用的I/O模型，非阻塞I/O</li></ol><blockquote><p>什么是多路复用模型</p><p>多路复用模型就是利用一些能够可以监察多个IO流的能力(select,poll,epoll)。在空闲的时候就可以把当前线程阻塞掉，当有一个或多个IO流的时候，就从阻塞态唤醒，然后程序会轮询一遍所有的的流，而且只依次顺序处理就绪的流，避免了大量的无用操作。</p><p>这里的多路指的就是<strong>多个网络连接</strong>，复用的是<strong>一个线程</strong>。</p><p>Reactor模式。</p></blockquote><ol start="5"><li>使用的底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li></ol><h1><span id="缓存穿透以及缓存雪崩">缓存穿透以及缓存雪崩</span></h1><h2><span id="缓存穿透">缓存穿透</span></h2><p>一般缓存系统都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找。部分恶意请求会故意查询不存在的key，请求量会很大，直接对后端系统造成压力，这就是缓存穿透。</p><blockquote><p>如何避免缓存穿透？</p><ol><li><p>对查询结果为空的情况也进行缓存，缓存时间设计的短一些。或者该key对应的数据insert了之后清理缓存。</p></li><li><p>对一定不存在的key进行过滤，可以把可能存在的key放在一个大bitmap中，查询时根据bitmap过滤。</p></li></ol></blockquote><h2><span id="缓存雪崩">缓存雪崩</span></h2><p>当缓存服务器重启或者大量缓存集集中在摸一个时段失效，在失效的时候会给后端系统带来很大的压力。这就是缓存雪崩。</p><blockquote><p>如何避免缓存雪崩呢？</p><ol><li><p>在缓存失效后，通过加锁或者队列来控制读写数据库的线程数，比如说某个特定的key只允许一个线程的查询和写缓存。</p></li><li><p>做二级缓存，当一级缓存失效时，可以访问二级缓存，一级缓存失效时间为短期，二级缓存为长期。</p></li><li><p>不同的key，设置不同的过期时间，让缓存失效的时间尽量均匀。</p></li></ol></blockquote><h1><span id="redis中的事务">Redis中的事务</span></h1><p>Redis由于是单线程，当事务开始，就完全不能被打断，是串行化操作，只有执行完当前正在执行的事务，才能执行下一个事务。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h1><span id="redis遵循cap定理">Redis遵循CAP定理</span></h1><p>redis本事是符合nosql的cap定理的。</p><p>分别是分区(p)，可用性(a)，一致性(c)。</p><p>nosql数据库只能做到：</p><ul><li><p>分区+可用性</p></li><li><p>分区+一致性</p></li></ul><h1><span id="redis的持久化机制">Redis的持久化机制</span></h1><p>Redis虽然是基于内存的数据库，但是为了保证断电后数据不丢失，需要将内存中的数据持久化到硬盘上。</p><h2><span id="rdb持久化">RDB持久化</span></h2><p>RDB是redis database的缩写，功能核心函数rdbsave(生成RDB文件)和rdbLoad(从文件加载内存)两个函数。</p><p>将某个时间点的数据都放到硬盘上。</p><p>可以将快照复制到其他服务器从而创建具有相同数据的服务器脚本。</p><p>如果系统发生故障，将会丢失最后一次快照之后的所有数据。</p><p>如果数据量很大，保存快照的时间就会很长。</p><h2><span id="aof持久化">AOF持久化</span></h2><p>将写命令添加到AOF文件的末尾。</p><p>使用AOF持久化需要设置同步选项，从而确保写命令到磁盘文件上的时机。这是因为对文件进行写入不会立刻将内容存储磁盘上，而是先写入缓冲区，然后由操作系统决定什么时候同步到磁盘。</p><p>WRITE:根据条件，将aof_buf中的缓存写入AOF文件。</p><p>SAVE:根据条件，调用fsync或者fdatasync，将AOF文件保存到本地磁盘。</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定合适同步</td></tr></tbody></table><h2><span id="两种方式的对比">两种方式的对比</span></h2><ol><li>AOF比RDB的更新频率高，优先使用AOF还原数据</li><li>AOF文件比RDB文件更大也更安全</li><li>RDB的性能要强于AOF</li><li>如果两个都使用了优先加载AOF</li></ol><h1><span id="redis中的过期处理">Redis中的过期处理</span></h1><p>在Redis中，使用的过期策略有三种，分别来对他们分析：</p><h3><span id="1-定时删除">1. 定时删除</span></h3><p>定时删除是指，在这个key被创建的时候，为这个key设置一个定时器，让这个key在过期时间来临的时候被删除。</p><p>优点是可以保证内存更快的释放。</p><p>缺点是因为过期的key非常多，频繁的删除清理操作会占用很大的CPU时间，在CPU紧张的时候，就会十分低效。如果每一个key都要创建一个定时器，定时器也会十分影响性能。</p><h3><span id="2-懒汉式删除">2. 懒汉式删除</span></h3><p>key过期的时候不主动删除，在每次在获取值的时候在检查是否过期了，如果过期了，就删除，同时返回null。</p><p>优点是是删除操作值只发生在获取值的时候，而且只删除这一个内容，对CPU占用比较少。</p><p>缺点是太多的key过期之后有可能很久都没有获取过，占用大量的内存。</p><h3><span id="3-定期删除">3. 定期删除</span></h3><p>每过一段时间，就检查一次有没有过期的内容，如果有，就删除。</p><p>优点是定时删除的优化，不用占用那么多cpu。</p><p>缺点是没有特色，太过均衡。</p><p>这种方式的关键在于设置执行频率和每次需要执行多久。只有比较好的设置了之后才能利用好该种的优点。</p><h3><span id="redis中采用的删除策略">Redis中采用的删除策略</span></h3><p>采用的是懒汉式删除和定期删除。</p><p>懒汉式删除流程：</p><ol><li>在进行get或setnx等操作时，先检查key是否过期。</li><li>如果过期，则删除key。</li><li>如果没过期，直接执行操作即可。</li></ol><p>定期删除流程：</p><ol><li>遍历整个数据库。</li><li>检查当前库中的指定个数的key（默认为20个key）</li><li>如果当前库中没有任何一个设置了过期时间的key，则执行下一个库的遍历。</li><li>随机获取一个设置了过期时间的key，则检查该key是否过期，如果过期，则删除。</li><li>判断定期删除是否达到指定时长，如果到达，则推出定期删除。</li></ol><h1><span id="redis的架构模式">Redis的架构模式</span></h1><h2><span id="单机架构模式">单机架构模式</span></h2><p>单个redis服务器，多个客户端访问。</p><p>特点，简单。</p><p>问题：</p><ol><li>内存容量有限</li><li>处理能力有限</li><li>无法高可用性</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM解析（二）</title>
      <link href="/2020/02/14/jvm-2/"/>
      <url>/2020/02/14/jvm-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此文章参考<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#3-%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener">Java 虚拟机</a></p></blockquote><h1><span id="gc篇">GC篇</span></h1><a id="more"></a><p>GC主要发生在Java堆和方法区，因为其为线程共享。</p><p>其他三个部分由于线程私有，在其线程结束后就被销毁，所以不需要对其他三个区进行GC。</p><h2><span id="判断一个对象可以回收的方法">判断一个对象可以回收的方法</span></h2><h3><span id="1-引用计数法">1. 引用计数法</span></h3><p>为每个对象添加一个引用计数器，增加一个引用时计数器＋1，减少一个引用计数器-1，当计数器为0的时候，这个对象就可以回收。</p><p>可能会出现循环引用的情况，即a是b的引用，同时b是a的引用，所以不使用该方法。</p><h3><span id="2-分析可达性算法">2. 分析可达性算法</span></h3><p>从GC Roots开始作为起点，开始进行搜索，能够到达的对象都是存活的，不能到达的对象都是需要进行回收的。</p><p>GCRoot包含的内容有：</p><ol><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中JNI中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ol><p><strong>算法中可能存在的问题：</strong></p><p>多线程环境可能会存在某种可能性，其他线程可能会更新已经访问过对象中的引用，可达性分析线程没有同步到最新的内容，可能就会产生漏报和误报，误报就可能产生一个对象在某个位置依然被引用，但是已经被回收了。</p><p><strong>解决方法</strong></p><p>在Java虚拟机中，每次启动垃圾回收，都会暂停其他所有线程的任务，直到垃圾回收完成，这有点像DIO的the world。必须要等待垃圾回收线程完成工作才能继续其他线程。这个时间就叫GC PAUSE。</p><p>所以JVM中设计了一个安全点(safepoint)，发出GC请求后，等待所有线程都到达安全点，才会开始GC。</p><h3><span id="3-方法区的回收">3. 方法区的回收</span></h3><p>方法区主要存放永久代对象，永久代对象回收率很低。</p><p>主要是对常量池的回收和对类的卸载。</p><p>卸载类的条件很多，需要满足以下3个条件，而且满足了也不一定会被回收。</p><ol><li>该类所有的实例都被回收，这时候堆中没有任何该类的实例对象。</li><li>加载该类的ClassLoader已经被回收</li><li>该类对应的Class对象没有被任何地方引用，所有地方都无法通过反射访问该类方法。</li></ol><h3><span id="4-finalize">4. finalize()</span></h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h2><span id="引用类型">引用类型</span></h2><h3><span id="1强引用">1.强引用</span></h3><p>被强引用的对象不会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><h3><span id="2软引用">2.软引用</span></h3><p>被软引用的对象只有在内存不够的时候才会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3><span id="3-弱引用">3. 弱引用</span></h3><p>若引用的对象一定被回收，只能存活到下次GC之前。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3><span id="4-虚引用">4. 虚引用</span></h3><p>又被称为幻影引用，有没有虚引用不会对这个对象的生存时间产生影响，也无法通过虚应用得到一个对象。</p><p>唯一的目的是在这个对象被回收的时候收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2><span id="垃圾收集算法">垃圾收集算法</span></h2><h3><span id="1标记-清除">1.标记-清除</span></h3><p>S1. 标记阶段，在标记阶段，程序检查每个对象是否为活动对象，如果是活动对象，在对象头部打上标记，</p><p>S2. 清除阶段，进行对象回收并取消标志位。同时判断回收后分块和前一个空闲分块是否连续，如果连续会合并这两个分块。回收工作就是把对象作为分块，并且将这些分块连接到‘空闲链表’的单向链表上。分配时只需要遍历链表就可以找到分块。</p><p>在分配时，程序会搜索空闲链表寻找大于等于新对象size的块，当找到相同大小的块直接返回，找到大于的块则会将其分割为两部分，一部分拿来用，另一部分返回空闲链表。</p><p><strong>不足</strong>：</p><ol><li>标记清除效率低</li><li>产生大量碎片化内存，大对象可能无法正常分配。</li></ol><h3><span id="2-标记-整理">2. 标记-整理</span></h3><p>让存活的对象向一端移动，直接清理边界外的内存。</p><p>虽然不会产生碎片，但是对象内存的移动，处理效率太低。</p><h3><span id="3复制">3.复制</span></h3><p>把内存分割为大小相同的两份，使用其中的一份。当这份内存用尽时，将当前存活的对象复制到另一份内存中，然后清理原来那一份内存。</p><p>吞吐量比较大。</p><p>最大的不足就是只使用了内存的一半。</p><h3><span id="4-分代收集">4. 分代收集</span></h3><p>根据对象存活周期来进行划分，一般划分为新生代和老年代。</p><p><strong>新生代</strong>一般使用复制算法</p><p><strong>老年代</strong>一般使用标记清除或者标记整理</p><h2><span id="垃圾收集器">垃圾收集器</span></h2><p>垃圾收集器的不同种类其实可以配合使用，常用的垃圾收集器有7种。</p><p>垃圾收集器也有不同的特性：</p><p><strong>单线程与多线程</strong>：单线程就是GC线程只有一个，多线程就是有多个。</p><p><strong>串行和并行</strong>：串行是指在运行GC的时候需要暂停用户程序(the world!)，并行指的的是GC和用户程序同步进行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p><h3><span id="1-serial收集器">1. Serial收集器</span></h3><p>直译为串行收集器，自然以串行的方式收集。</p><p>新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理算法</strong>。</p><p>同时也是一个单线程收集器，只有一个GC线程。</p><p>优点是简单高效，单个CPU内没有线程交互的开销，拥有最高的单线程收集效率。</p><p>其为Client场景下默认的新生代收集器，因为在该场景下内存一般不大。</p><h3><span id="2-parnew收集器">2. ParNew收集器</span></h3><p>其为Serial收集器的的多线程版本。</p><p>其为Server场景下默认的新生代收集器，除了Serial收集器外，只有ParNew收集器能与CMS收集器共用。</p><h3><span id="3-parallel-scavenge收集器">3. Parallel Scavenge收集器</span></h3><p>其为多线程收集器。</p><p>新生代采用<strong>复制算法</strong>，老年代采用<strong>标记-整理</strong>算法。</p><p>其他收集器的目标是缩短GC停顿时间，而这个收集器的目标是达到一个可控的吞吐量，所以也被称为吞吐量收集器。</p><blockquote><p>此处吞吐量指CPU用于运行用户程序占总程序运行时间的比值。</p></blockquote><p>短的停顿时间适合用户交互型程序。高吞吐量则适合后台运算型程序。</p><p>停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的，新生代空间变小，垃圾回收变得频繁，吞吐量下降。</p><h3><span id="4-serial-old收集器">4. Serial Old收集器</span></h3><p>是Serial收集器的老年代版本，在Client场景下的虚拟机使用。如果在Server场景下，其有两大用途：</p><ol><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ol><h3><span id="5-parallel-old-收集器">5. Parallel Old 收集器</span></h3><p>是Parallel Scavenge收集器的老年代版本。</p><h3><span id="cms收集器">CMS收集器</span></h3><p>CMS(Concurrent Mark Sweep)，多线程标记清除算法。</p><p>流程如下：</p><ol><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ol><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ol><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ol><h3><span id="7-g1收集器">7. G1收集器</span></h3><p>(Garbage-first)，是一个面向服务端应用的垃圾收集器，在多CPU和大内存场景下有较好的性能。</p><p>整体上采用标记-整理算法，局部采用复制算法(两个Region之间)。运行期间不会产生空间碎片。</p><p>其他收集器都是针对新生代或者老年代进行手机，而G1收集器直接对新生代老年代一起回收。</p><p>G1把堆分割成多个大小相同的对立区域(Region)，新生代和老年代不在物理隔离。</p><p>Region将一整块内存空间分割成多个小空间，使得每个小空间可以单独进行垃圾回收，十分灵活。通过记录Region垃圾回收时间以及回收所得到的空间，维护一个优先列表，回收目标是回收价值最大Region。</p><p>每个Region都有一个Remembered Set，用于记录Region对象的引用对象所在的Region，从而避免可达性分析是的全堆扫描。</p><p>不计算维护set的草所，收集器的工作步骤如下：</p><ol><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正并发标记种，因为用户线程继续运行而导致变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Log 中。这个阶段需要停顿线程，但是可以并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p><h2><span id="内存分配和回收策略">内存分配和回收策略</span></h2><h3><span id="minor-gc-和-full-gc">Minor GC 和 Full GC</span></h3><p><strong>Minor GC</strong>: 回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度也比较快。</p><p><strong>Full GC</strong>：回收老年代和新生代，老年代存活时间长，因此Full GC很少执行，而且比Minor GC 慢很多。</p><h3><span id="新生代内存分析">新生代内存分析</span></h3><p>JVM将新生代分为三个部分，一个Eden区和两个survivor区(分别叫from和to)，默认比例是8：1：1。</p><blockquote><p>这里为什么是8:1:1。首先因为from区和to区的大小相同，如果重新设置也必须设置成相同的形式，而eden区是8，因为有统计和经验表明，大多数的对象都是朝生夕死，很少有能存活非常久的对象。</p></blockquote><p>一般情况下，新创建的对象会被分配到Eden区，这些对象经过一次Minor GC之后，如果仍然存活，就会被移动到Survivor区。对象在Survivor区中每经过一次Minor GC，年龄就会增加1岁。当年龄增加到一定程度，就会被移入老年代。</p><p>因为新生代的对象大部分都是生的快死的快，所以在新生代的垃圾回收使用的是复制算法。</p><ol><li><p>GC开始的时候，对象只会存在于Eden区和From Survivor区，TO 区是空的。</p></li><li><p>然后开始进行GC，Eden区的所有存活对象被移动到To区，From区中仍然存活的对象根据年龄来决定去留，如果年龄达到阈值，则被移入老年代；其余则被复制入To区。</p></li><li><p>此时From区和Eden区被清空，同时From区和To区交换身份。从而保证To区在GC开始的时候都是空的。</p></li><li><p>当To区被填满后，To区的所有对象被移入老年代。</p></li></ol><h2><span id="内存分配策略">内存分配策略</span></h2><h3><span id="1-对象优先在eden分配">1. 对象优先在Eden分配</span></h3><p>大多数情况下，对象直接在Eden上分配。当Eden空间不足时，发起Minor GC.</p><h3><span id="2大对象直接进入老年代">2.大对象直接进入老年代</span></h3><p>大对象指需要连续内存的对象，比如很长的String或者数组。</p><p>经常出创建对象会提前触发GC以获取足够大的连续空间分配给大对象。</p><h3><span id="3-长期存活的对象直接进入老年代">3. 长期存活的对象直接进入老年代</span></h3><p>即年龄大于阈值后进入老年代。</p><h3><span id="4-动态对象年龄判定">4. 动态对象年龄判定</span></h3><p>即当Survivor中相同年龄的所有对象大小的总和大于Survivor区的一半，则年龄大于或等于该年龄的对象可以直接进入老年代。无需达到阈值。</p><h3><span id="5-空间分配担保">5. 空间分配担保</span></h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h2><span id="触发full-gc的条件">触发Full GC的条件</span></h2><h3><span id="1-调用systemgc">1. 调用System.gc()</span></h3><p>只是建议虚拟机执行Full GC，虚拟机不一定会执行，不建议用这种方式。</p><h3><span id="2-老年代空间不足">2. 老年代空间不足</span></h3><p>大对象，长期存活的对象太多。</p><p>为了避免该方式，尽量避免创建大对象和大数组。除此外，可以调整JVM参数调大新生代大小，让对象尽可能在新生代被回收。也可以通过调大对象进入老年代的年龄，让对象在新生代多存货一段时间。</p><h3><span id="3空间分配担保失败">3.空间分配担保失败</span></h3><p>参考上一节的最后一个内容</p><h3><span id="4jdk17以前的永久代空间不足">4.JDK1.7以前的永久代空间不足</span></h3><p>JDK7以前，方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><h3><span id="5-concurrent-mode-failure">5. Concurrent Mode Failure</span></h3><h2><span id="jvm工具和部分jvm参数">JVM工具和部分JVM参数</span></h2><h3><span id="jvm性能监控工具">JVM性能监控工具</span></h3><table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>jps</td><td>监控虚拟机进程工具</td></tr><tr><td>jstat</td><td>收集虚拟机运行数据</td></tr><tr><td>jinfo</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程与并发(1)</title>
      <link href="/2020/02/13/java-concurrent1/"/>
      <url>/2020/02/13/java-concurrent1/</url>
      
        <content type="html"><![CDATA[<h1><span id="线程-进程与多线程的创建">线程、进程与多线程的创建</span></h1><a id="more"></a><blockquote><p>本节内容参考<a href="https://blog.csdn.net/weixin_44797490/article/details/91006241" target="_blank" rel="noopener">Java多线程超详解</a></p></blockquote><h2><span id="线程-进程是什么">线程、进程是什么</span></h2><p><strong>进程</strong>：进程就是一个正在运行的程序。</p><p><strong>线程</strong>：线程是一种轻量级的进程，实际存在于一个进程内。</p><h2><span id="并发和并行是是什么">并发和并行是是什么</span></h2><p><strong>并发</strong>：并发是多个任务在同一时间需要处理，只有一个处理器进行工作，在这一刻只能运行其中一个任务。</p><p><strong>并行</strong>：并行是在拥有多个处理器的时候，两个处理器可以分别运行两个线程。</p><h2><span id="线程的状态有哪些">线程的状态有哪些</span></h2><p>Java线程的状态有六种，就绪(ready),阻塞(blocked)，等待(waiting),正在运行(runnable),线程刚创建(new),超时等待(timed_waiting)，运行终结(terminated)。</p><p><img src="/img/thread.jfif" alt="线程状态转换图"></p><p><strong>初始状态(new)</strong></p><p>当经过继承Thread或者实现Runnable接口的类被实例化，该线程进入初始状态。</p><p><strong>就绪状态(ready)</strong></p><ol><li>就绪状态就是可以随时准备运行的状态，这时候需要等待系统调度。</li><li>当一个线程启动了start()方法，就可以进入就绪状态。</li><li>当这个线程的sleep()方法结束，其他线程的join()方法结束，用户输入完成，线程拿到对象锁，这些情况线程都将进入就绪状态。</li><li>当前时间片运行结束，调用yield()方法，会让当先处于运行态的线程进入就绪态</li><li>锁池中的线程拿到对象锁，进入就绪状态。</li></ol><p><strong>运行状态(runnable)</strong></p><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式</p><p><strong>阻塞(block)</strong></p><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态</p><p><strong>等待(waiting)</strong></p><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态</p><p><strong>超时等待(timed_waiting)</strong></p><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><p><strong>运行终结(terminated)</strong></p><p>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</p><h2><span id="线程的调度">线程的调度</span></h2><p>Java的线程服务策略是：</p><ol><li>对于同优先级的线程，执行先到先服务的政策(FIFS)，组成队列，采用时间片策略</li><li>对优先级高的线程，就先服务。</li></ol><h2><span id="多线程的创建与使用">多线程的创建与使用</span></h2><h3><span id="继承thread类">继承Thread类</span></h3><p>通过继承Thread类，可以完成创建多线程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        window t1 = <span class="keyword">new</span> window();</span><br><span class="line">        window t2 = <span class="keyword">new</span> window();</span><br><span class="line">        window t3 = <span class="keyword">new</span> window();</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"售票口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"售票口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"售票口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>; <span class="comment">//将其加载在类的静态区，所有线程共享该静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(getName()+<span class="string">"当前售出第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>start()和run()</strong></p><p>start()是真正意义上启动了一个线程，而run()只是调用了一次run()方法内的代码。</p><h3><span id="实现runnable接口">实现Runnable接口</span></h3><p>实现Runnable接口也可以实现多线程操作。常用此方法而不是继承Thread，因为单继承会限制。<br><figure class="highlight java"><figcaption><span>public class ThreadDemo01 &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        window1 w = <span class="keyword">new</span> window1();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//虽然有三个线程，但是只有一个窗口类实现的Runnable方法，由于三个线程共用一个window对象，所以自动共用100张票</span></span><br><span class="line">        </span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"当前售出第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="callable">Callable</span></h3><p>与使用runnable方式相比，callable功能更强大些：<br>runnable重写的run方法不如callaalbe的call方法强大，</p><p>call方法可以有返回值</p><p>方法可以抛出异常</p><p>支持泛型的返回值</p><p>需要借助FutureTask类，比如获取返回结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现callable接口的call方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以抛出异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//new一个实现callable接口的对象</span></span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过futureTask对象的get方法来接收futureTask的值</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//get返回值即为FutureTask构造器参数callable实现类重写的call的返回值</span></span><br><span class="line">           Object sum = futureTask.get();</span><br><span class="line">           System.out.println(Thread.currentThread().getName()+<span class="string">":"</span>+sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1><span id="java内存模型jmm">Java内存模型(JMM)</span></h1><p>Java内存模型涉及到部分有关于多线程的内容。</p><p>JMM定义了JVM在计算机内存中的工作方式，JMM隶属于JVM。</p><p>JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都私有一个本地内存，本地内存中存储了该线程以读写的共享变量副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他硬件的编译器优化。</p><p>一个局部变量，如果是原始类型，那么将会在栈区被分配；如果是一个对象，他的引用在栈区，而实际对象在堆区。</p><p>这样的本地内存，带来了一些问题：</p><h2><span id="java内存模型的问题">Java内存模型的问题</span></h2><h3><span id="可见性问题">可见性问题</span></h3><p>CPU中运行的线程A从主存中拷贝共享对象到他的CPU缓存，把对象中的变量从1变更为2；而对于线程B，同样拷贝了一份共享对象。然而由于本地内存的存在，线程A的更改结果在他的本地缓存从，并没有写入主存，所以这个修改对线程B来说实际上是不可见的。我们可以通过加锁的方式或者使用volatile关键字。</p><h3><span id="竞争现象">竞争现象</span></h3><p>A、B两个线程，同时使用共享对象obj，两个线程同时修改obj.val = obj.val + 1。在本地内存存在的情况下，写回的数值是val+1，而我们的预期值是val+2。出现这种现象，就需要同步代码块来解决这个问题。</p><h2><span id="java内存模型中的重排序">Java内存模型中的重排序</span></h2><hr><h1><span id="多线程并发">多线程并发</span></h1><h2><span id="线程安全">线程安全</span></h2><p>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><h2><span id="线程间通信">线程间通信</span></h2><p>与操作系统类似，Java也需要一种进程间通信的手段。用来处理线程并发时，可能存在的数据不一致性。为了解决Race condition，Java也使用了自己的手段来保证并发数据同步的问题。</p><p>线程间的状态有两种，同步和异步。</p><p><strong>同步</strong></p><p>同步描述的是两个线程A，B；当A线程请求资源R，但B线程在此刻使用资源R，A线程必须等待B线程释放资源R才可以获取资源R。</p><p><strong>异步</strong></p><p>异步描述的是两个线程A,B；当A线程请求资源R，B线程拥有资源R，A线程不用等待B线程使用释放资源，立刻就能获得资源R。</p><p>在这种情况下为了保证数据的一致性，Java使用锁来保证线程间的同步。</p><h2><span id="锁">锁</span></h2><p>对于锁，他的含义其实是当有某个线程/任务在访问一段代码时，可能会出现多条线程访问同一段代码，这种情况下可能会出现数据不一致的情况，为了解决这个问题，首先要对这段要访问的代码上一把锁，只有拥有了这把锁的线程，才可以访问这段代码。</p><p>而由于Java是面向对象的语言，所以对一段代码，可能是属于一个对象，可能是属于一整个类，所以要根据需要，选择不同的封锁粒度。</p><p>接下来用代码来先描述一个典型的 <strong>锁对象</strong>。</p><h3><span id="锁对象">锁对象</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestThread test1 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        TestThread test2 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        TestThread test3 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里使用同一个对象来启动三个线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段可能要并发的程序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"try to enter the code block"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">            shortSleep();</span><br><span class="line">            System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段程序在一个线程中运行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SynchTest test;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        test = <span class="keyword">new</span> SynchTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        test.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这段程序的运行结果是三个线程同时进入运行，同时试图访问临界区代码，可以发现他们是一个一个的进入运行，begins和ends交替出现。</p></blockquote><blockquote><p>这段代码对一个对象进行封锁，所以当使用同一个对象创建三条线程，在这三条线程对这个对象的操作，他们的操作必须按照调度依次进行。</p></blockquote><p><strong>那么更改这个代码中的一部分，即入口函数的代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestThread test1 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        TestThread test2 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        TestThread test3 = <span class="keyword">new</span> TestThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这里使用不同的对象来启动三个线程</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(test1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(test2);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(test3);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>那么这三个线程就会异步执行，同时开始，同时结束，他们的begins和ends基本是同一时间出现的，证明不同对象之间并不存在锁的概念。</p></blockquote><h3><span id="锁类">锁类</span></h3><p>有些时候，某些类同样也需要被锁住，当这个类在到处都被不同的实例化的时候，有些代码需要跨对象的被锁住，这时候就需要用到锁类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在上一份代码的基础上继续进行修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"try to enter the code block"</span>);</span><br><span class="line">        <span class="comment">//修改这里的代码为某一个类</span></span><br><span class="line">        <span class="keyword">synchronized</span>(SynchTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">            shortSleep();</span><br><span class="line">            System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>程序运行结果又是begins和ends交替出现，而不是一下都出现了。代表不同实例化的对象在执行临界区代码时同步执行。</p></blockquote><p>还有一种情况会出现锁类，那就是synchronized修饰静态方法，静态方法同类的对象共用，所以理所应当时锁类的。</p><p>修改这份代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//这里修改为静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"try to enter the code block"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(SynchTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">            shortSleep();</span><br><span class="line">            System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shortSleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestThread</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里直接运行静态方法</span></span><br><span class="line">        SynchTest.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="线程同步的方法">线程同步的方法</span></h2><h3><span id="同步代码块">同步代码块</span></h3><p>使用同步代码块的方式可以灵活的，比较细粒度的构造同步代码块区域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(SynchTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">            shortSleep();</span><br><span class="line">            System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种方法比较灵活，之将可能需要同步的代码放入代码块中，以求部分的线程同步需求。</p><h3><span id="同步方法">同步方法</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">            shortSleep();</span><br><span class="line">            System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法对整个方法修饰，锁的话默认是this，和以下代码近似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">        shortSleep();</span><br><span class="line">        System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>如何检测这条线程是否拥有一把锁(同步监视器)？</p><p>Thread.holdsLock(obj)方法可用于检测是否拥有一把锁，参数为那把锁的名字。</p></blockquote><h3><span id="使用lock">使用lock</span></h3><p>还有一种方式是使用ReentrantLock类提供的lock()和unlock()方法来划分临界区，它的优点是比较灵活，自由控制粒度。缺点是需要手动释放锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"try to enter the code block"</span>);</span><br><span class="line">       lock.lock();</span><br><span class="line">           System.out.println(<span class="string">"test begins"</span>);</span><br><span class="line">           shortSleep();</span><br><span class="line">           System.out.println(<span class="string">"test ends"</span>);</span><br><span class="line">       lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="volatile">volatile</span></h3><p>在接下来的部分提到</p><h3><span id="threadlocal">threadlocal</span></h3><h3><span id="阻塞队列">阻塞队列</span></h3><h3><span id="原子变量">原子变量</span></h3><h3><span id="使用lock和synchronized的区别">使用lock和synchronized的区别</span></h3><ol><li>lock实际上时java的一个类，而synchronized是java的内置关键字，是在jvm层面实现的。</li><li>synchronized无法判断是否获取锁，而lock可以判断是否获取到锁</li><li>synchronized自动释放锁，而lock需要手动释放</li><li>当lock无法取得锁时，线程不用一直等待。</li><li>synchronized可重入，不可中断，非公平；而lock可重入，可判断，可公平</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java From Basic To Advanced (3)</title>
      <link href="/2020/02/01/java-base3/"/>
      <url>/2020/02/01/java-base3/</url>
      
        <content type="html"><![CDATA[<p>该文章参考内容：</p><blockquote><p><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a></p></blockquote><blockquote><p><a href="https://blog.csdn.net/login_sonata/article/details/76598675" target="_blank" rel="noopener">Java8的HashMap详解</a></p></blockquote><a id="more"></a><!-- toc --><ul><li><a href="#java容器类二">Java容器类（二）</a><ul><li><a href="#map">Map</a><ul><li><a href="#hashmap">HashMap</a><ul><li><a href="#总览">总览</a></li><li><a href="#存储结构">存储结构</a></li><li><a href="#方法分析">方法分析</a></li><li><a href="#hashmap总结">HashMap总结</a></li></ul></li></ul></li><li><a href="#hashset">HashSet</a></li></ul></li><li><a href="#序列化和反序列化">序列化和反序列化</a><ul><li><a href="#什么是序列化和反序列化">什么是序列化和反序列化</a></li><li><a href="#序列化和反序列化的使用方法">序列化和反序列化的使用方法</a></li><li><a href="#类中部分字段不进行序列化">类中部分字段不进行序列化</a></li><li><a href="#静态成员变量不参与序列化过程">静态成员变量不参与序列化过程</a></li><li><a href="#serialversionuid">serialVersionUID</a></li></ul></li><li><a href="#io">IO</a><ul><li><a href="#bio和nio的区别">BIO和NIO的区别</a></li><li><a href="#传统io的认识">传统IO的认识</a></li><li><a href="#同步异步-和-阻塞非阻塞的区别">同步/异步 和 阻塞/非阻塞的区别</a><ul><li><a href="#同步-与-异步">同步 与 异步</a></li><li><a href="#阻塞-与-非阻塞">阻塞 与 非阻塞</a></li></ul></li><li><a href="#nio-解析">NIO 解析</a><ul><li><a href="#流与块">流与块</a></li><li><a href="#通道与缓冲区">通道与缓冲区</a></li></ul></li><li><a href="#选择器selector">选择器(Selector)</a></li></ul></li></ul><!-- tocstop --><h2><span id="java容器类二">Java容器类（二）</span></h2><h3><span id="map">Map</span></h3><p>在Map接口中，除了看见Map的常用方法以外，还有一个名为Entry的内部类，该内部类用于作为数据链上的一个数据节点。</p><p><img src="/img/hashmap.png" alt="HashMap存储结构"></p><h4><span id="hashmap">HashMap</span></h4><h5><span id="总览">总览</span></h5><p>根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全。在并发编程时，需要使用ConcurrentHashMap。</p><p>如果非要使用线程安全的HashMap，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br></pre></td></tr></table></figure><p>在Map类中，作为key的对象的哈希值必须是不可变的。</p><h5><span id="存储结构">存储结构</span></h5><p>HashMap是数组+链表+红黑树的存储结构。</p><p>当同哈希值在链地址法的情况下的链表长度大于8(默认值)，该链表就换转化成红黑树，以提高增删改查的效率。(O(n)-&gt;O(logn))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为内部类存于HashMap类，作为存储节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在HashMap类中，也有一些参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储节点的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//实际在Map中节点的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//出现线程问题时，负责及时抛异常</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">// 扩容阈值 </span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure></p><p>而这个size必须是2的次幂。</p><blockquote><p>Q:为什么是2的次幂呢？</p><p>Ans:哈希表进行定位的时候需要进行模运算，而在这里使用了一个精妙的方法：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p></blockquote><h5><span id="方法分析">方法分析</span></h5><p>put方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">put方法入口</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//首先判断table是否是null，如果是，对其进行一次扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用&amp;代替模运算，加快确定哈希位置的速度</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果该位置没有任何一个元素，则直接添加一个新节点</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果有数据，则进入后续处理</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果key存在，则覆盖原数据</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//如果是红黑树，进入红黑树处理阶段</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//循环遍历插入链表</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果大于固定链表长度，则转化为红黑树</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>扩容方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//现有容量大于最大容量，则放大扩容阈值</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">//在这里进行扩容操作</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5><span id="hashmap总结">HashMap总结</span></h5><p>(1) 扩容是一个特别耗性能的操作，所以使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) HashMap是线程不安全的，在并发的环境中建议使用ConcurrentHashMap。</p><p>(3) JDK1.8引入红黑树大程度优化了HashMap的性能，这主要体现在hash算法不均匀时，即产生的链表非常长，这时把链表转为红黑树可以将复杂度从O(n)降到O(logn)。</p><p>HashMap在Map.Entry静态内部类实现中存储key-value对。HashMap使用哈希算法，在put和get方法中，它使用hashCode()和equals()方法。当我们通过传递key-value对调用put方法的时候，HashMap使用Key hashCode()和哈希算法来找出存储key-value对的索引。</p><p>(4)当使用自定对象作为key时，必须要重写equals()方法和hashCode()方法。</p><h3><span id="hashset">HashSet</span></h3><p>HashSet的底层存储本质其是一个默认容量为16的HashMap，并且在源码中，将存入set中的元素，存储在HashMap的key中。</p><h2><span id="序列化和反序列化">序列化和反序列化</span></h2><blockquote><p>该部分参考<a href="https://www.cnblogs.com/myseries/p/11931512.html" target="_blank" rel="noopener">java 序列化和反序列化的底层实现原理</a></p></blockquote><h3><span id="什么是序列化和反序列化">什么是序列化和反序列化</span></h3><p>  （1）Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程；</p><p>　（2）<strong>序列化</strong>：序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p><p>　（3）<strong>反序列化</strong>：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p><p>　（4）本质上讲，序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态。</p><p>  那什么时候需要进行序列化和反序列化呢？</p><p>  （1）永久性保存对象，保存对象的字节序列到本地文件或者数据库中；</p><p>（2）通过序列化以字节流的形式使对象在网络中进行传递和接收；</p><p>（3）通过序列化在进程间传递对象；</p><h3><span id="序列化和反序列化的使用方法">序列化和反序列化的使用方法</span></h3><p>首先需要构造一个合适的类来实现Serializable接口，给类中添加get、set方法，设置一个serialVersionUID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1012085199478534057L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间标示</span></span><br><span class="line">    <span class="keyword">private</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  String key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValueTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValueTest</span><span class="params">(String value, String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setvalue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getkey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setkey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ValueTest&#123;"</span> +</span><br><span class="line">                <span class="string">"序列化存储时间："</span> + date +</span><br><span class="line">                <span class="string">", value='"</span> + value + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", key='"</span> + key + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要讲到关于序列化和反序列化相关的两个类，用于处理序列化相关的IO操作。</p><p>（1）ObjectOutputStream：表示对象输出流；</p><p>　　它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中；</p><p>（2）ObjectInputStream：表示对象输入流；</p><p>　　它的readObject()方法源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ValueTest ValueTest = <span class="keyword">new</span> ValueTest(<span class="string">"test"</span>,<span class="string">"test"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\ValueTest"</span>))) &#123;</span><br><span class="line">            os.writeObject(ValueTest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先睡5秒</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 基本步骤：</span></span><br><span class="line"><span class="comment">         * ① 创建输入流对象ObjectOutputStream。同样依赖于其它输入流对象，这里是文件输入流 FileInputStream</span></span><br><span class="line"><span class="comment">         * ② 通过 ObjectInputStream 的 readObject()方法，将文件中的对象读取到内存</span></span><br><span class="line"><span class="comment">         * ③ 关闭流 同上</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\ValueTest"</span>))) &#123;</span><br><span class="line">            ValueTest o = (ValueTest) is.readObject();</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            System.out.println(<span class="string">"当前时间："</span>+<span class="keyword">new</span> Date());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="类中部分字段不进行序列化">类中部分字段不进行序列化</span></h3><p>当一个类中存在某部分信息不需要进行序列化的时候，需要使用transient。比如说在前面分析过的ArrayList中存储数据的部分就被transient修饰了，证明该部分在正常序列化过程中被忽略。</p><blockquote><p>那为什么ArrayList等容器类依然可以被正常序列化呢</p><p>实际上在各集合类中，对序列化和反序列化部分都有单独实现，并不通过常用的序列化和反序列化方式。因为容器类中可能含有部分NULL值元素，所以为了减少无用序列化的发生，提高空间利用率，在容器类中该方法被重写。</p></blockquote><h3><span id="静态成员变量不参与序列化过程">静态成员变量不参与序列化过程</span></h3><p>静态成员其实是类本身的状态，而序列化的目标是该对象的状态，序列化前后的静态成员值只与当前类中静态成员变量有关，与读取无关。</p><h3><span id="serialversionuid">serialVersionUID</span></h3><p>从官方文档中可得：</p><blockquote><p>如果可序列化类未显式声明 serialVersionUID，则序列化运行时将基于该类的各个方面计算该类的默认 serialVersionUID 值，如“Java(TM) 对象序列化规范”中所述。<br>不过，强烈建议 所有可序列化类都显式声明 serialVersionUID 值，原因是计算默认的 serialVersionUID 对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的 InvalidClassException。<br>因此，为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。还强烈建议使用 private 修饰符显示声明 serialVersionUID（如果可能），原因是这种声明仅应用于直接声明类</p><p>– serialVersionUID 字段作为继承成员没有用处。数组类不能声明一个明确的 serialVersionUID，因此它们总是具有默认的计算值，但是数组类没有匹配 serialVersionUID 值的要求。</p></blockquote><h2><span id="io">IO</span></h2><p>Java的IO系统主要是传统IO系统(BIO)和新IO系统(NIO)。</p><h3><span id="bio和nio的区别">BIO和NIO的区别</span></h3><p>BIO，即为Java传统的IO包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</p><p>NIO，是在Java1.4引入的新IO包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</p><h3><span id="传统io的认识">传统IO的认识</span></h3><p>传统IO有这几种类型：</p><ul><li>InputStream、OutputStream 基于字节操作的IO</li><li>Reader、Writer 基于字符操作的IO</li><li>File 基于磁盘操作的IO</li><li>Socket 基于网络操作的IO</li></ul><p>java.io 下的类和接口很多，但大体都是 InputStream、OutputStream、Writer、Reader 的子集，所有掌握这4个类和File的使用，是用好 IO 的关键。</p><h3><span id="同步异步-和-阻塞非阻塞的区别">同步/异步 和 阻塞/非阻塞的区别</span></h3><h4><span id="同步-与-异步">同步 与 异步</span></h4><p>同步就是指一个任务的完成依赖于前一个任务的完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p><p>而异步是指不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。。</p><h4><span id="阻塞-与-非阻塞">阻塞 与 非阻塞</span></h4><p>阻塞就是需要等该任务完成，才能干其他事。</p><p>非阻塞就是多个线程在工作时，按照效率不同可以相互切换，不用等待该任务的完成。</p><table><thead><tr><th></th><th>同步</th><th>异步</th></tr></thead><tbody><tr><td>阻塞</td><td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。也就是传统IO包采取的方式</td><td>这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td></tr><tr><td>非阻塞</td><td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。 这种方式通常能提升 I/O 性能，但是会增加CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td><td>种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。</td></tr></tbody></table><h3><span id="nio-解析">NIO 解析</span></h3><h4><span id="流与块">流与块</span></h4><p>NIO和传统IO包最大的不同就是流与块的概念。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。</p><h4><span id="通道与缓冲区">通道与缓冲区</span></h4><p><strong>通道</strong></p><p>实际上是对原IO包中流的模拟，可以通过它读写数据。</p><p>通道与流的不同在于，流是单向的，而通道是双向的，可以单独读/单独写/读写同时进行。</p><p>通道有以下种类：</p><ul><li>FileChannel 从文件中读写数据</li><li>DatagramChannel 通过UDP读写网络中的数据</li><li>SocketChannel 通过TCP读写网络中的数据</li><li>ServerSocketChannel 可以监听新进来的TCP连接，每一个新进入的连接都会船舰一个SocketChannel。</li></ul><p><strong>缓冲区</strong></p><p>发送给通道的所有数据必须放入缓冲区，同样从通道中读取的数据也需要先读入缓冲区。从这方面来讲，我们不能直接对通道进行数据读写，必须先经过缓冲区。</p><p>缓冲区的实质是一个数组。缓冲区提供了对数据的结构化访问，还可以跟踪系统的读写进程。</p><p>缓冲区包括：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><p>也就是说，每一种数据类型都对应一种数据缓冲区。</p><h3><span id="选择器selector">选择器(Selector)</span></h3><p>NIO被叫做非阻塞IO，主要是因为NIO在网络通信中非阻塞特性被广泛使用。</p><p>NIO实现了IO多路复用的Reactor模型，一个线程使用一个选择器通过轮询的方式监听多个通道的时间，让一个线程就可以处理多个时间。</p><p>通过配置监听通道的方式为非阻塞，就能当通道上的IO事件未到达时，就不会进入阻塞状态一直等待，而是继续轮询其他通道，找到IO事件到达的通道来执行任务。</p><p>因为创建和切换线程的开销很大，因此要使用一个线程来处理多个线程，而不是一对一，对于IO密集型的应用来说有很好的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建选择器</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将通道注册到选择器上</span></span><br><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">//配置选择器是否为阻塞</span></span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听事件,返回值为到达的事件的个数,同时阻塞等待就绪的Channel</span></span><br><span class="line"><span class="keyword">int</span> num selectot.select();</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环监听</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//获取到达的事件</span></span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span>(keyIterator.hasNext)&#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span>(key.isAcceptable)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的事件监听常常是需要循环监听的，为了让线程持续运行，需要将获取的到达的事件放在while循环中。</p><blockquote><p>实际上，在register方法的第二个参数是有多种选择的。这个参数的含义是对哪一种事件感兴趣，比如说在这里就是对接收数据感兴趣。分别是SelectionKey.OP_CONNECT 对连接感兴趣。SelectionKey.OP_ACCEPT 对接收感兴趣。SelectionKey.OP_READ 对读取感兴趣。SelectionKey.OP_WRITE 对写数据感兴趣</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java From Basic To Advanced (2)</title>
      <link href="/2020/01/15/java-base2/"/>
      <url>/2020/01/15/java-base2/</url>
      
        <content type="html"><![CDATA[<p>第二章内容主要围绕容器。</p><a id="more"></a><!-- toc --><ul><li><a href="#stringbuilder-与-stringbuffer">StringBuilder 与 StringBuffer</a><ul><li><a href="#stringbuilder与stringbuffer的存储根基">StringBuilder与StringBuffer的存储根基</a></li><li><a href="#string和这两者有什么区别呢">String和这两者有什么区别呢</a></li><li><a href="#那么stringbufferbuilder和数组有什么区别呢">那么StringBuffer/builder和数组有什么区别呢</a></li></ul></li><li><a href="#java提供的数据结构">Java提供的数据结构</a></li><li><a href="#接口与抽象类">接口与抽象类</a></li><li><a href="#java异常处理机制">Java异常处理机制</a></li><li><a href="#java泛型">Java泛型</a><ul><li><a href="#泛型类">泛型类</a></li><li><a href="#泛型接口">泛型接口</a></li><li><a href="#泛型通配符">泛型通配符</a><ul><li><a href="#泛型通配符的上限和下限">泛型通配符的上限和下限</a></li><li><a href="#pecs原则">PECS原则</a></li></ul></li></ul></li><li><a href="#java容器类一">Java容器类（一）</a><ul><li><a href="#iterable接口">Iterable接口</a></li><li><a href="#collection接口">Collection接口</a></li><li><a href="#list-queue-set">List、Queue、Set</a><ul><li><a href="#arraylist">ArrayList</a><ul><li><a href="#分析常用方法">分析常用方法</a></li></ul></li><li><a href="#其他">其他</a></li></ul></li></ul></li></ul><!-- tocstop --><h2><span id="stringbuilder-与-stringbuffer">StringBuilder 与 StringBuffer</span></h2><p>把这两个类放在一起谈的原因是，他们共同继承了AbstractStringBuilder抽象类，拥有共同的存储根基。</p><h3><span id="stringbuilder与stringbuffer的存储根基">StringBuilder与StringBuffer的存储根基</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于存储字符串</span></span><br><span class="line"><span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于分辨字符串的编码方式，分辨Latin1和UTF-16</span></span><br><span class="line"><span class="keyword">byte</span> coder;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于标识现在已经使用的字符数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>从这几个存储根基可以看出来，它的存储方式和String类似。</p><p>同时，StringBuilder是线程不安全的，在多线程编程时，不能保证其隔离性。</p><p>为什么不能保证其隔离性呢？</p><p>拿常用的append()方法举例,在他们的共同抽象类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    <span class="comment">//下一步的操作并非原子操作，当多线程并发时，该操作多线程不能保证其写回的数据的正确性</span></span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再观察StringBuffer对append的操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用synchronized关键字修饰，表示该方法被并发控制，所以其多线程操作可以保证其隔离性。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再观察StringBuffer的源码，大量方法都被synchronized修饰，所以它为什么线程安全也不难理解了。</p><h3><span id="string和这两者有什么区别呢">String和这两者有什么区别呢</span></h3><p>String的内容被final修饰，不可更改，而这两个可以随意更改，在字符串内容反复变化的时候，就应该使用这两个类，否则字符串的+操作，也同样是转化为StringBuilder操作，这样会增加临时数据在常量池中的数量，增加GC压力。</p><p>在多线程的情况下，StringBuffer是同步的，数据安全的，但是效率相对较低；而StringBuilder是不同步的，数据不安全的，但是效率很高。</p><h3><span id="那么stringbufferbuilder和数组有什么区别呢">那么StringBuffer/builder和数组有什么区别呢</span></h3><p>他们同样是数据容器，但是StringBuffer他们只为字符串工作，而数组为多种数据种类工作。</p><h2><span id="java提供的数据结构">Java提供的数据结构</span></h2><p>Java本身提供了一些数据结构，比如栈，向量，哈希表等。</p><p>后来有了集合(collection)类，就后面再讨论。</p><p>栈的基本操作如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//向15压栈</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Integer(<span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> res = stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈顶元素弹栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查看栈是不是空的。</span></span><br><span class="line">        <span class="keyword">if</span>(stack.empty())&#123;</span><br><span class="line">            <span class="comment">//something</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//something</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上，我们也可以使用两个栈来构造一个队列，队列的特性就是先进先出，我们如何使用先进后出的栈结构来实现呢？</p><p>先将元素压入stack1入队，当需要出队的时候，把stack1的元素都弹如stack2中，在将元素从stack2弹出就完成了出队操作。当stack2为空时，再将stack1的元素弹如stack2即可完成两个栈模拟队列的操作。</p><h2><span id="接口与抽象类">接口与抽象类</span></h2><p>接口和抽象类简直是老生常谈了，先看看他们的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  接口的实现方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//接口中的方法全部为抽象方法</span></span><br><span class="line">    <span class="comment">//接口中可以定义变量，且变量默认被public static final修饰，必须被初始化。</span></span><br><span class="line">    <span class="comment">//接口中没有构造方法，不能实例化</span></span><br><span class="line">    <span class="comment">//接口中的方法，永远被public修饰</span></span><br><span class="line">    <span class="comment">//接口中的方法只有声明，没有实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">someFunction</span><span class="params">(<span class="keyword">int</span> someValue)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 抽象类的实现方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//可以在抽象类中定义变量</span></span><br><span class="line">    <span class="keyword">int</span> someVaule;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> someStaticValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//抽象类中可以有构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//抽象类中可以实现非抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//抽象类中的方法可以被private修饰</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以被protected修饰</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//可以被public修饰</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法可以被声明为子类必须实现的抽象方法，含有抽象方法的类必须是抽象类。抽象方法可以不被实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以有静态方法,也可以有main方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ps:不能有静态抽象方法，且抽象类不可以被实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>类可以不实现抽象类和接口声明的所有方法，在这种情况下，类也必须得声明成是抽象的。</p></li><li><p>类可以实现很多个接口，但是只能继承一个抽象类</p></li></ol><h2><span id="java异常处理机制">Java异常处理机制</span></h2><h2><span id="java泛型">Java泛型</span></h2><p>java泛型是Java中的重要机制，它与接下来分析的容器类有着十分紧密的关联。</p><p>泛型分为泛型类，泛型方法，泛型接口。</p><h3><span id="泛型类">泛型类</span></h3><p>泛型类可以类中的多个方法来定义相同类型的接口，比如接下来要分析的List等容器类。用一段代码来描述泛型类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用泛型时，需要指定类型，否则编译不通过。</p><h3><span id="泛型接口">泛型接口</span></h3><p>而泛型接口与泛型类相似，代码来描述写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当一个类实现泛型接口时，有两种情况，一种是指定了泛型的类型，另一种时没有指定泛型的类型，使用代码描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未指定泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定泛型类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherClass</span> <span class="keyword">implements</span> <span class="title">Test</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="泛型通配符">泛型通配符</span></h3><p>泛型通配符是用来解决一类问题的，即泛型是特定指定的，即在使用泛型的时候，子类并不能放入父类的容器中，这和Java设计的一部分理念违背，所以引入泛型通配符来解决这个问题。</p><p><strong>通配符是在创建泛型对象时使用的</strong></p><p>用一段代码来描述通配符的使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无边界通配符的使用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Test&lt;Number&gt; number = <span class="keyword">new</span> Test&lt;Number&gt;(<span class="number">111</span>);</span><br><span class="line">        Test&lt;Integer&gt; integer = <span class="keyword">new</span> Test&lt;Integer&gt;(<span class="number">222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行方法，将会打印出111和222</span></span><br><span class="line">        getValue(number);</span><br><span class="line">        getValue(integer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该情况描述的是持有某种特定类型的List</span></span><br><span class="line">        List&lt;?&gt; listSp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该情况描述的是持有Object类型的的List</span></span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//被注释的部分不可执行，因为无法确认通配符代表的类型，所以不能向集合中添加元素，但是可以删除和清空元素</span></span><br><span class="line">        <span class="comment">//listsp.add(111);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以向list集合中添加任意元素</span></span><br><span class="line">        list.add(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">(Test&lt;?&gt; data)</span></span>&#123;</span><br><span class="line">        System.out.println(data.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="泛型通配符的上限和下限">泛型通配符的上限和下限</span></h4><p>可以使用一种方法来规定通配符所匹配的上界和下界：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用该方法确定通配符的上界</span></span><br><span class="line"><span class="comment">//这个方法表示的是，继承了Number的子类和number类的所有实例化的类都可以转入该容器。</span></span><br><span class="line">List&lt;? extends Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用该方法确定通配符的下界</span></span><br><span class="line"><span class="comment">//这个方法用来确认装入容器中的类必须是Number的父类和number类，比如说Integer类就无法装入该容器中。</span></span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;(); </span><br><span class="line">List&lt;? <span class="keyword">super</span> Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure><h4><span id="pecs原则">PECS原则</span></h4><p>对于上边界限定的通配符，无法向其中加入任何对象，但是可以从中正常取出对象。</p><p>对于下边界限定的通配符，可以存入subclass对象或者subclass的子类对象，但是取出时只能用Object类型变量指向取出的对象。</p><p>当一个数据结构作为producer对外提供数据的时候，应该只能取数据而不能存数据，所以适合使用上边界限定（extends）的通配符。</p><p>当一个数据结构作为consumer获取并存入数据的时候，应该只能存数据而不能取数据，所以适合使用下边界限定（super）的通配符。</p><p>如果既需要取数据也需要存数据，就不适合使用泛型的通配符。</p><h2><span id="java容器类一">Java容器类（一）</span></h2><p>容器类是Java的一种用来存储数据的数据结构，通过一张图就能清晰的描述Java容器类的种类和他们之间的关系。</p><p><img src="/img/collection.jpg" alt="容器类构成图"></p><p>一个一个的从源头上讲：</p><h3><span id="iterable接口">Iterable接口</span></h3><p>从源头上讲，它实际上是迭代器支持类，只有继承了该接口的类，才可以使用foreach来进行遍历。</p><h3><span id="collection接口">Collection接口</span></h3><p>Collection接口是用于实现一些基本容器方法的，该接口本身并不提供直接继承的类，都是子接口扩展后在进行的。</p><h3><span id="list-queue-set">List、Queue、Set</span></h3><p>这三个数据容器接口是最常用的数据容器接口，他们都继承了collection接口。</p><p>List是有序的数据，可以重复。具有代表性的可以用List接口承接的类有ArrayList，LinkedList。</p><h4><span id="arraylist">ArrayList</span></h4><p>看一下ArrayList的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于容量参数为0时调用的构造器时需要的参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于无参构造时调用的部分</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用一个Object数组来存储数据，因为Object是所有类的父类，所以所有的类都可以装到这个数组里</span></span><br><span class="line"><span class="comment">//这里的特殊修饰符，transient作用是让改属性不被序列化</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>同时拥有三种构造方法，分别是无参构造，容量为参数的构造，容器为参数的构造。</p><h5><span id="分析常用方法">分析常用方法</span></h5><p>分析一下源码中的常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素方法分析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, Object[] elementData, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">            <span class="comment">//空间不够的时候，对类中的数组进行扩容</span></span><br><span class="line">            elementData = grow();</span><br><span class="line">        elementData[s] = e;</span><br><span class="line">        size = s + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向外暴露的方法，调用私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        add(e, elementData, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用复制后扩容的函数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] grow(<span class="keyword">int</span> minCapacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> elementData = Arrays.copyOf(elementData,newCapacity(minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//扩容函数的入口</span></span><br><span class="line">    <span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">        <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在这里确定新数组的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">                <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">            <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">            <span class="keyword">return</span> minCapacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">            ? newCapacity</span><br><span class="line">            : hugeCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在这里检查是否越界</span></span><br><span class="line">        Objects.checkIndex(index, size);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//remove方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Objects.checkIndex(index, size);</span><br><span class="line">        <span class="keyword">final</span> Object[] es = elementData;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E oldValue = (E) es[index];</span><br><span class="line">        fastRemove(es, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>从源码上看，就可以看出ArrayList本身线程不安全，在多线程编程时十分危险。</p><h4><span id="其他">其他</span></h4><p>Set是无序的数据，不可重复。</p><p>而Queue接口可以承载各种非阻塞队列的实现。</p><p>而List本身线程并不安全，如果需要线程安全则需要使用Vector。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java From Basic To Advanced (1)</title>
      <link href="/2020/01/11/java-base1/"/>
      <url>/2020/01/11/java-base1/</url>
      
        <content type="html"><![CDATA[<h2><span id="写在整个系列的最前面">写在整个系列的最前面</span></h2><p>从开始写Java到现在已经过去两年了，基础的GUI到JDBC到IO文件都是很杂乱的学习，今天开始从最基础最基础的部分开始学习，面向面试，面向开发，面向从零开始的深入过程，从头开始整合所有的Java知识点。<br><a id="more"></a></p><hr><!-- toc --><ul><li><a href="#java基本数据类型">Java基本数据类型</a><ul><li><a href="#引用类型">引用类型</a></li><li><a href="#基本数据类型和他们的包装类型">基本数据类型和他们的包装类型</a></li><li><a href="#auto-boxing自动装箱">Auto Boxing(自动装箱)</a></li><li><a href="#包装类型是不变类">包装类型是不变类</a></li><li><a href="#integercache">IntegerCache</a></li></ul></li><li><a href="#java运算符">Java运算符</a></li><li><a href="#java修饰符">Java修饰符</a></li><li><a href="#java-string类型">Java String类型</a><ul><li><a href="#string的存储方式基于jdk11">String的存储方式(基于JDK11)</a></li><li><a href="#string的常用构造方法及在内存中的存储方式">String的常用构造方法及在内存中的存储方式</a></li><li><a href="#字符串常用方法分析">字符串常用方法分析</a></li></ul></li></ul><!-- tocstop --><h2><span id="java基本数据类型">Java基本数据类型</span></h2><ol><li>byte (-2^7 ~ 2^7 -1)</li><li>short(-2^15 ~ 2^15 -1)</li><li>int  (-2^31 ~ 2^31 -1)</li><li>long (-2^63 ~ 2^63 -1)</li><li>float(32位浮点数)</li><li>double(64位浮点数)</li><li>boolean(布尔类型)</li><li>char(字符类型)</li></ol><p>Java中使用final可以用来声明一些常量。</p><h3><span id="引用类型">引用类型</span></h3><p>Java中指向对象的变量都是引用类型，可以把它们看作是传统c程序的指针，声明一个引用类型不能直接赋值使用，需要使用new开辟新的存储空间，或者指向已经存在的对象。</p><h3><span id="基本数据类型和他们的包装类型">基本数据类型和他们的包装类型</span></h3><p>每一个基本数据类型都有其对应的包装类，对应关系如下</p><table><thead><tr><th>基本类型</th><th>包装类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table><p>包装类型的作用是为了满足面向对象编程的特性，同时可以在基本数据类型上也可以使用应用类型(比如说null的时候)。</p><h3><span id="auto-boxing自动装箱">Auto Boxing(自动装箱)</span></h3><p>自动装箱和自动拆箱是Java编译器帮我们实现的，在基本数据类型和包装类型之间自动转换的功能.</p><p>但是在转换的时候可能会产生空指针异常,使用的时候要注意。</p><p>现在用实例来讲解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//手动声明基本类型变量</span></span><br><span class="line">        <span class="keyword">int</span> basicData <span class="number">8</span>; </span><br><span class="line">        <span class="comment">//手动装箱        </span></span><br><span class="line">        Integer Box = <span class="keyword">new</span> Integer(basicData);</span><br><span class="line">        <span class="comment">//手动拆箱</span></span><br><span class="line">        <span class="keyword">int</span> manuallyUnboxing = Box.intValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动装箱,自动使用Integer.valueOf()</span></span><br><span class="line">        Integer AutoBoxing = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">//自动拆箱,自动使用Integer.intValue()</span></span><br><span class="line">        <span class="keyword">int</span> autoUnboxing = AutoBoxing;</span><br><span class="line"></span><br><span class="line">        Integer NullPointer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//发生空指针异常</span></span><br><span class="line">        <span class="keyword">int</span> errorHappened = NullPointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="包装类型是不变类">包装类型是不变类</span></h3><p>深入包装类型源码分析，可以发现包装类型被Final修饰，证明包装类型的对象一旦被创建，这个对象就不可更改。</p><h3><span id="integercache">IntegerCache</span></h3><p>这是包装类的日常考点。</p><p>Java会在自动装箱Integer类型的包装类时，判断这个数字的大小，当这个数字在-128~127之间的时候，就会把这个数字缓存起来。</p><p>用代码来说明情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用valuOf()方法创建，值在区间内，触发缓存</span></span><br><span class="line">        Integer n1 = Integer.valueOf(<span class="number">5</span>);</span><br><span class="line">        Integer n2 = Integer.valueOf(<span class="number">5</span>);</span><br><span class="line">        System.out.println(n1 == n2); <span class="comment">//此处为true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此处使用自动装箱，同样相当于调用valueOf()，触发缓存</span></span><br><span class="line">        Integer n3 = <span class="number">127</span>;</span><br><span class="line">        Integer n4 = <span class="number">127</span>;</span><br><span class="line">        System.out.println(n3 == n4);<span class="comment">//此处为true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//此处使用自动装箱，不在区间内，不触发缓存</span></span><br><span class="line">        Integer n5 = <span class="number">128</span>;</span><br><span class="line">        Integer n6 = <span class="number">128</span>;</span><br><span class="line">        System.out.println(n5 == n6);<span class="comment">//此处为false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处使用new创建对象，虽然在区间内，但不使用valueOf()方法，所以不触发缓存。</span></span><br><span class="line">        Integer n7 = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Integer n8 = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        System.out.println(n7 == n8);<span class="comment">//此处为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>包装类型的比较应改使用equals()方法而不是==进行比较。</strong></p><hr><h2><span id="java运算符">Java运算符</span></h2><p>基本运算符与普通编程语言相似，强调一下短路运算：</p><p>&amp;是与运算，即算符左右都为真，结果为真，但如果是&amp;&amp;，则是如果前面为假，后面就不运算了。</p><p>前者是非短路运算，后者是短路运算，短路运算出现在&amp;和|算符上。</p><p>不推荐使用非短路运算。</p><hr><h2><span id="java修饰符">Java修饰符</span></h2><h2><span id="java-string类型">Java String类型</span></h2><p>开始从一切的根源，也就是String类的源码实现开始分析。</p><h3><span id="string的存储方式基于jdk11">String的存储方式(基于JDK11)</span></h3><p>String类的存储方式是通过常量池实现的，当使用以下方法来创建一个字符串时，其实时通过创建一个字符串常量，然后让该String的引用类型变量指向存放该字符串常量的地址。</p><p><strong>分析一下String的存储根基</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPACT_STRINGS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        COMPACT_STRINGS = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Native</span> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> LATIN1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Native</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span> UTF16  = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>value</strong></p><p>在JDK9之前，原本是一个char类型的字符数组(16bit)，但是ISO-8859-1编码前面的8bit都是被浪费掉了，所以使用8bit的byte数组。</p><p>实现这个的意义是性能优化，但对于中文数据来说这个优化的意义并不明显。</p><p><strong>coder</strong></p><p>用来存储该字符串对象的编码方式。</p><p>字符串的编码方式，如果是UTF16的话就要吧value转成16字节的char数组</p><p><strong>hash</strong></p><p>存储该字符串的hash值，当没有使用hashCode()方法时，该值默认为0。</p><p><strong>COMPACT_STRINGS</strong></p><p>COMPACT_STRINGS 默认将 COMPACT_STRINGS 设置为 true。而如果要取消紧凑的布局可以通过配置 VM 参数-XX:-CompactStrings实现。</p><h3><span id="string的常用构造方法及在内存中的存储方式">String的常用构造方法及在内存中的存储方式</span></h3><p><strong>无参数的构造方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>以字符串为参数的构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = original.coder;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会将原有字符串的常量池地址赋给新字符串的value，而自己本身的引用则在堆中重新分配内存，也就是说，该指针并非直接指向常量池中的字符串。</p><p><strong>直接赋值的方法</strong></p><p>该方法在使用时，会先从常量池中搜锁是否存在相同的常量字符，如果有，则指向该常量字符串，否则将新的字符串注入到常量池中。</p><p>如果出现以下情况<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"world"</span>;</span><br><span class="line">str1 = str1 + str2;</span><br></pre></td></tr></table></figure></p><p>在这种情况下，JVM会自主调用StringBuilder,首先使用str1完成初始化，然后再调用append()方法合并str2，接下来调用toString()方法将新的字符串放入常量池，最后将str1的指针重新指向新生成的”helloworld”串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><p>在源码文档的注解中，这种方式近似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br></pre></td></tr></table></figure><p>我们再来分析一下这个方法调用的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(value, <span class="number">0</span>, value.length, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len, Void sig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">this</span>.coder = LATIN1;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.coder = UTF16;</span><br><span class="line">    <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果COMPACT_STRINGS=true，则采用LATIN1编码方式，如果其中有一个字符不在LATIN1编码范围内，则采用UTF-16编码。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//LATIN1：StringUTF16.compress(value, off, len)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">char</span>[] val, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="keyword">if</span> (compress(val, off, ret, <span class="number">0</span>, len) == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//LATIN1:char[]--&gt;byte[]</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] src, <span class="keyword">int</span> srcOff, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOff, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src[srcOff];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0xFF</span>) &#123;<span class="comment">//判断是否在LATIN1编码0~255范围内</span></span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果不在则返回，用UTF16编码方式</span></span><br><span class="line">        &#125;</span><br><span class="line">        dst[dstOff] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        srcOff++;</span><br><span class="line">        dstOff++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//UTF16：StringUTF16.toBytes(value, off, len)</span></span><br><span class="line"><span class="comment">//UTF16:char[]---&gt;byte[]</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toBytes(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] val = newBytesFor(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        putChar(val, i, value[off]);</span><br><span class="line">        off++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//newBytesFor() 因为utf16编码方式，一个char占用16bit，一个byte占用8bit，一个char会占用2个byte的长度，这个函数计算出char[]数组转换为bit[]之后，bit[]数组的长度。 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] newBytesFor(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NegativeArraySizeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; MAX_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"UTF16 String size is "</span> + len +</span><br><span class="line">                                   <span class="string">", should be less than "</span> + MAX_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len &lt;&lt; <span class="number">1</span>];<span class="comment">//左移一位，相当于乘以2.</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将char字符写入到byte数组中。一个char字符，写入到byte[]中，占用两个位置。</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="comment">// intrinsic performs no bounds checks</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(<span class="keyword">byte</span>[] val, <span class="keyword">int</span> index, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length(val) : <span class="string">"Trusted caller missed bounds check"</span>;</span><br><span class="line">    index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    val[index++] = (<span class="keyword">byte</span>)(c &gt;&gt; HI_BYTE_SHIFT);</span><br><span class="line">    val[index]   = (<span class="keyword">byte</span>)(c &gt;&gt; LO_BYTE_SHIFT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HI_BYTE_SHIFT;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LO_BYTE_SHIFT;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isBigEndian()) &#123;</span><br><span class="line">        HI_BYTE_SHIFT = <span class="number">8</span>;</span><br><span class="line">        LO_BYTE_SHIFT = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HI_BYTE_SHIFT = <span class="number">0</span>;</span><br><span class="line">        LO_BYTE_SHIFT = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，String类型在被压缩为byte了之后，用了大量的方法来实现byte和char类型的适配工作。</p><h3><span id="字符串常用方法分析">字符串常用方法分析</span></h3><p><strong>length()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length &gt;&gt; coder();</span><br></pre></td></tr></table></figure><p>为什么要使用右移运算呢，因为length的长度是基于byte数组设计的，而当使用的是UTF-16编码的时候，byte数组的长度是两倍的char数组的长度，所以在这里使用的是右移运算，当编码方式为UTF-16时，coder()的返回值为1，右移一位，也就是除以2。</p><p><strong>charAt(int index)</strong></p><p>这个函数功能就是返回字符串索引处的字符。</p><p>因为String分为了两种编码形式，所以需要对应不同的实现方式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLatin1()) &#123;</span><br><span class="line">        <span class="keyword">return</span> StringLatin1.charAt(value, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUTF16.charAt(value, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//latin:byte[]--&gt;char  StringLatin1.charAt(value, index)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里因为返回的是char类型的字符，在Latin1编码的状态下，要保持高8位的状态为0。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(value[index] &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//utf16:byte[]--&gt;char StringUTF16.charAt(value, index)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkIndex(index, value);</span><br><span class="line">    <span class="keyword">return</span> getChar(value, index);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//byte[]--&gt;char </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> <span class="title">getChar</span><span class="params">(<span class="keyword">byte</span>[] val, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length(val) : <span class="string">"Trusted caller missed bounds check"</span>;</span><br><span class="line">    index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(((val[index++] &amp; <span class="number">0xff</span>) &lt;&lt; HI_BYTE_SHIFT) |</span><br><span class="line">                  ((val[index]   &amp; <span class="number">0xff</span>) &lt;&lt; LO_BYTE_SHIFT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>equals()</strong></p><p>equals()方法用于判断两个字符串是否相等，在这里的实现方法如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="comment">//首先判断两个的引用是否相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">//判断是否是一个String对象</span></span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="comment">//在这里在分别分两种方法重写equals()</span></span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                              : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>intern()</strong></p><p>在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。</p><p>还有大量的字符串方法，都使用了对应char和byte的处理方式。</p><p>下一章讲解StringBuilder和StringBuffer。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划笔记</title>
      <link href="/2020/01/09/dp-1/"/>
      <url>/2020/01/09/dp-1/</url>
      
        <content type="html"><![CDATA[<p>假期动态规划刷题笔记</p><a id="more"></a><!-- toc --><ul><li><a href="#最大子序列和">最大子序列和</a><ul><li><a href="#题目描述">题目描述</a></li><li><a href="#解题思路">解题思路</a></li><li><a href="#解题代码">解题代码</a></li></ul></li><li><a href="#最小路径和">最小路径和</a><ul><li><a href="#题目描述-1">题目描述</a></li><li><a href="#解题思路-1">解题思路</a></li><li><a href="#解题代码-1">解题代码</a></li></ul></li><li><a href="#三角形最小路径和">三角形最小路径和</a><ul><li><a href="#解题思路-2">解题思路</a></li><li><a href="#解题代码-2">解题代码</a></li></ul></li><li><a href="#零钱兑换-leetcode322">零钱兑换 leetcode.322</a><ul><li><a href="#题目描述-2">题目描述</a></li><li><a href="#解题思路-3">解题思路</a></li><li><a href="#代码实现">代码实现</a></li></ul></li><li><a href="#完全平方数-leetcode279">完全平方数 leetcode.279</a><ul><li><a href="#题目描述-3">题目描述</a></li><li><a href="#解题思路-4">解题思路</a></li><li><a href="#代码实现-1">代码实现</a></li></ul></li><li><a href="#打家劫舍leetcode198">打家劫舍,leetcode.198</a><ul><li><a href="#解题思路-5">解题思路</a></li><li><a href="#代码实现-2">代码实现</a></li></ul></li></ul><!-- tocstop --><h3><span id="最大子序列和">最大子序列和</span></h3><p>(LeetCode#53)</p><h4><span id="题目描述">题目描述</span></h4><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p><strong>Input:</strong> [-2,1,-3,4,-1,2,1,-5,4],</p><p><strong>Output:</strong> 6</p><p><strong>Explanation:</strong>[4,-1,2,1] has the largest sum = 6.</p><h4><span id="解题思路">解题思路</span></h4><p>这道题的重点在于写出最大子序列的状态转移方程：</p><center>f(n) = max( f(n - 1) + A(n) , A(n) )</center><p>然后根据该方程编写DP程序。</p><h4><span id="解题代码">解题代码</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">            <span class="comment">// 当序列程度小于1时，提前处理边界情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">0</span>;temp &lt; nums.length;temp++)&#123;</span><br><span class="line">            dp[temp] = nums[temp];</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">                <span class="comment">//处理可能的越界情况，即[0-1]</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[temp] = Math.max(dp[temp-<span class="number">1</span>]+dp[temp],dp[temp]);</span><br><span class="line">                max = Math.max(max,dp[temp]);</span><br><span class="line">                <span class="comment">//dp核心方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3><span id="最小路径和">最小路径和</span></h3><p>(LeetCode#64)</p><h4><span id="题目描述">题目描述</span></h4><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p><p>示例:</p><p><strong>输入:</strong></p><p>[</p><p>  [1,3,1],</p><p>  [1,5,1],</p><p>  [4,2,1]</p><p>]</p><p><strong>输出:</strong> 7</p><p><strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。</p><h4><span id="解题思路">解题思路</span></h4><p>首先看到最小，可以优先考虑以下动态规划，同时发现前一个状态和后一个状态是有相关关系的，所以采用动态规划解题方法。</p><p>首先定义一个dp二维矩阵，对应题目给出的矩阵。</p><p>确定矩阵的dp[0][0]的值与net[0][0]相同。</p><p>题目中给出，只能向下或者向右移动一步，所以可以确认上边缘和左边缘。(上边缘/左边缘只能由其左方/上方的前一个方格抵达)</p><center>dp[0][t] = dp[0][t-1] + net[0][t]</center><center>dp[t][0] = dp[t-1][0] + net[t][0]</center><p>确认上左边缘后，对于其他方格，只能接收来自上方和左方的路径，也就是该方格的状态是该方格上方和左方的小的那一个值加上net[ i ][ j ];</p><center>dp[ row ][ col ] = min( dp[ row -1 ][ col ],dp[ row ][ col - 1 ] ) + net[ row ][ col ]</center><p>返回dp[ m - 1 ][ n - 1 ]即可；</p><h4><span id="解题代码">解题代码</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length &lt; <span class="number">1</span> || grid[<span class="number">0</span>] == <span class="keyword">null</span> || grid[<span class="number">0</span>].length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//提前解决边界问题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        temp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//初始化dp矩阵的上、左边缘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>;t &lt; n;t++)&#123;</span><br><span class="line">            temp[<span class="number">0</span>][t] = temp[<span class="number">0</span>][t - <span class="number">1</span>] + grid[<span class="number">0</span>][t];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>;t &lt; m;t++)&#123;</span><br><span class="line">            temp[t][<span class="number">0</span>] = temp[t-<span class="number">1</span>][<span class="number">0</span>] + grid[t][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp矩阵内部单元求解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l &lt; m;l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p = <span class="number">1</span>;p &lt; n;p++)&#123;</span><br><span class="line">                temp[l][p] = Math.min(temp[l-<span class="number">1</span>][p],temp[l][p-<span class="number">1</span>]) + grid[l][p];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="三角形最小路径和">三角形最小路径和</span></h3><p>(LeetCode#120)</p><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p><p>例如，给定三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><h4><span id="解题思路">解题思路</span></h4><p>最小路径大概率涉及到动态规划，如果是自顶向下分析，可能性和情况是扩张的，所以试着用自底向上的分析方法来分析。</p><p>写出状态转移方程：</p><p>语言描述：在本元素的下层两个可达元素中选择最小的，加上本位置的元素值。</p><p>因为最底层没有下层元素，所以在dp矩阵的层数创建上要大于原本三角形层数一层.</p><center>dp[i][j] = min( dp[i+1][j],dp[i+1][j+1]) + currentLevel[i]</center><h4><span id="解题代码">解题代码</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle == <span class="keyword">null</span> || triangle.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()+<span class="number">1</span>][triangle.size()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = triangle.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            List&lt;Integer&gt; currentLevel = triangle.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; currentLevel.size();j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) + currentLevel.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="零钱兑换-leetcode322">零钱兑换 leetcode.322</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><h4><span id="解题思路">解题思路</span></h4><p>自底向上，使用动态规划的思路</p><p>设dp[n]为在使用面值为n的情况下，使用的硬币最少数量，则可以得到公式：</p><p>dp[0] = 0;<br>dp[n] = Max(min(dp[n - (one of coins’ face value)]+1),INT_MAX)</p><p>当dp[0]时为0；</p><p>当dp[n]时，dp[n]的数值则是在n减去一种硬币的面值之后依然合法的情况下，取减去一个硬币后的需要的硬币数dp[n-m]最小的一个数字</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">0</span>;temp &lt; amount + <span class="number">1</span>;temp++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">99999</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[temp] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[temp] = <span class="number">999999</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">                    <span class="keyword">int</span> preIndex = temp - coin;</span><br><span class="line">                    <span class="keyword">if</span>(preIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//dp[temp] = Math.min(999999,dp[temp]);</span></span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[temp] = Math.min(dp[temp],dp[temp - coin] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount] &gt; <span class="number">900000</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="完全平方数-leetcode279">完全平方数 leetcode.279</span></h3><h4><span id="题目描述">题目描述</span></h4><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><h4><span id="解题思路">解题思路</span></h4><p>和上面一个找硬币的解题思路类似，使用动态规划，在减去一个小于当前数的完全平方数后的情况中选一个最小的+1就是当前情况所需的最小值。</p><p>dp[0] = 0;</p><p>dp[1] = 1;</p><p>dp[n] = min( min(dp[n - (one of the sqrt number)]+1) ,min)</p><p>也就是说在里面找到一种最佳情况，需要从最接近n的完全平方数开始遍历。</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">2</span>;temp &lt;= n;temp++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">99999999</span>;</span><br><span class="line">            <span class="keyword">int</span> minSqrt = (<span class="keyword">int</span>)Math.sqrt(temp);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> incr = minSqrt;incr &gt; <span class="number">0</span>;incr--)&#123;</span><br><span class="line">                min = Math.min(dp[temp-incr*incr]+<span class="number">1</span>,min);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[temp] = min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="打家劫舍leetcode198">打家劫舍,leetcode.198</span></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><h4><span id="解题思路">解题思路</span></h4><p>这道题的解题思路其实比较简单，动态规划即可。</p><p>设dp[n]为在第n个房子处能偷到的最大的钱数，那么就有两种可能行，偷上家，和不偷上家。偷上家，那么这家就不能偷；不偷商家，那这家就能偷。这两种情况那种偷的多，就选择哪种。</p><p>首先边界条件，如果只有一个房子，那么dp[0] = nums[0];</p><p>如果有两个房子，那么dp[1] = Max(nums[0],nums[1]);</p><p>当n&gt;2时：</p><p>dp[n] = max(dp[n-1],dp[n-2] + nums[n]),即选择要不要偷上家。</p><h4><span id="代码实现">代码实现</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>] &gt; nums[<span class="number">0</span>]?nums[<span class="number">1</span>]:nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">2</span>;temp &lt; nums.length;temp++)&#123;</span><br><span class="line">        dp[temp] = Math.max(dp[temp - <span class="number">1</span>],dp[temp - <span class="number">2</span>]+nums[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL底层索引结构分析</title>
      <link href="/2019/11/23/mysql-fin/"/>
      <url>/2019/11/23/mysql-fin/</url>
      
        <content type="html"><![CDATA[<p>MySQL有两种常用的引擎，他们实现索引的数据结构相同，但实现方法却不同<br><a id="more"></a></p><h2><span id="聚簇索引-和-非聚簇索引">聚簇索引 和 非聚簇索引</span></h2><h3><span id="聚簇索引是什么">聚簇索引是什么？</span></h3><p>聚簇索引是将数据与索引结构放在一起，找到索引的同时也找到了数据。</p><p>而非聚簇索引则是索引和数据分离，索引的最终叶子节点存放了指向数据对应行的指针。</p><p><strong>聚簇索引具有唯一性。</strong></p><p>由于数据和索引放在一起，所以一份数据表只能存放一份和数据在一起的索引。</p><h3><span id="各个索引的搜索过程">各个索引的搜索过程</span></h3><p>在Innodb中，在聚簇索引之上创建的索引都称为辅助索引，辅助索引总是需要二次查找的。非聚簇索引都是辅助索引，比如说复合索引，唯一索引，前缀索引等，都在innodb中属于辅助索引，此时叶子节点存储的值并不是行位置的指针，而是主键值和字段值。</p><p>Innodb中的搜索过程如下：</p><p><img src="/img/innodb.png" alt="Inoodb搜索过程"></p><p>图中，<strong>红色</strong>的搜索过程为聚簇索引的搜索过程，<strong>绿色</strong>的搜索过程为非聚簇索引的搜索过程。</p><p>可以发现，当数据按照B+Tree组织起来时，行数据就直接存储在叶子节点上，当按照主键搜索时，就直接按照B+tree的检索算法就可以找到数据了。在图中用红色代表出来。</p><p>如果对其他辅助索引进行搜索，则需要两个步骤，首先在辅助索引中搜索字段的要求，然后在其叶子节点中获取到主键值，第二步再从聚簇索引中在进行一次搜索，获取到整个行的数据。在图中的流程用绿色表达出来。</p><p>而在MyISAM引擎中则不同，在该引擎中使用的时非聚簇索引，所以他的各种搜索过程都是类似的。</p><p><img src="/img/myisam.png" alt="MyIsam搜索过程"></p><p>在此引擎中，无论是不是主键，搜索过程都是一次的，不需要二次访问主键构成的索引树。</p><h2><span id="索引数据结构的筛选前导">索引数据结构的筛选前导</span></h2><p>在筛选索引的时候，B+Tree在没有被优化时是B-tree。</p><h3><span id="b-tree">B-Tree</span></h3><p>这种数据结构有些特色：</p><ul><li>首先是当某个节点的数据数量超过阈值将会自我分裂，产生下级节点</li><li>叶子节点的深度相同</li><li>叶子节点的指针为空</li><li>节点中数据的key从左到右递增</li></ul><p>结构是这样的：</p><p><img src="/img/b-tree.png" alt="b-tree"></p><p>我们可以发现，数据和索引是放在同一个节点的。</p><p>可以从上面索引的角度上来说，这种结构应该是被淘汰了，分析一下淘汰的原因：</p><p>虽然单条查找非常快，但是处理多条数据的时候，就会出现必须每次都要从根节点搜索的问题，而在数据库操作中常常是范围查找的，所以需要对该结构优化。</p><h3><span id="btree">B+Tree</span></h3><p>为了优化范围查找的问题，我们必须要将被上了索引的地方连起来，把不连续的地方用指针连起来，为了指针指向的有序性，就不能再将数据存储在每个中间节点中，如果把数据和索引存储在叶子节点中，就可以有序的指向不连续的节点了。</p><p>那么要做的操作：</p><ol><li>需要我们将索引和数据节点放在底层的叶子节点上，同时保持部分B-Tree的特性。</li><li>我们需要将不连续的叶子节点连起来</li></ol><p>所以我们改进之后的数据结构将如下图所示：</p><p><img src="/img/b+tree.png" alt="b+tree"></p><p>我们完成了改造后，这就是MySQL索引的基本结构。</p><h2><span id="myisam-和-innodb索引的底层原理">MyISAM 和 Innodb索引的底层原理</span></h2><h3><span id="myisam">MyISAM</span></h3><p>在MyISAM中使用的是非聚簇索引，索引文件和数据文件分离，索引文件最后存储的是指向数据文件中行数据的指针。</p><h4><span id="主键索引和辅助索引">主键索引和辅助索引</span></h4><p>MyISAM中，主键索引和非主键索引都是非聚簇索引，所以他们的存储方式都是以上所说的方法。</p><h3><span id="innodb">Innodb</span></h3><p>在Innodb中，索引和数据文件在同一个文件中，辅助索引为主键索引服务。</p><h4><span id="主键索引">主键索引</span></h4><p>主键索引使用聚簇索引，使用B+Tree组织数据，并且在叶子节点中直接存储数据信息。</p><h4><span id="辅助索引">辅助索引</span></h4><p>Innodb的辅助索引建立在主键索引之上，使用非聚簇索引，叶子节点中存储的是索引字段的值和对应的主键。查询过程见本文最上方。</p><p>为什么要在这里存储主键值而不是行地址指针呢？</p><p>因为如果对主键索引的某种修改可能导致表结构和地址的变化，如果使用行地址指针，会让更新数据变得十分复杂。</p><p>而使用指向主键值，对辅助索引在更新时就不用更新了，只需要更新主键索引就可以了。</p><h4><span id="innodb需要注意的">Innodb需要注意的</span></h4><ul><li>数据文件和索引文件在一起</li><li>直接按照B+Tree组织</li><li>聚簇索引的叶子节点直接包含完整行数据</li><li>Innodb必须要有主键，并且推荐自增主键</li></ul><blockquote><p>为什么要使用自增主键呢？</p><p>ANS: 因为自增主键在插入操作时不会u主动破坏书的结构，使用非递增主键会破坏结构，可能会导致插入复杂度上升。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Hadoop + Zookeeper + Hbase云服务器完全分布式环境</title>
      <link href="/2019/10/30/hadoop-init/"/>
      <url>/2019/10/30/hadoop-init/</url>
      
        <content type="html"><![CDATA[<p>首先说明，配置Hadoop的环境真的可以称得上是绝对噩梦，这篇博文记录下配置环境时遇到的各种各样的问题。</p><p>任何机器和服务器都有自己的特点，必须根据自己的不同情况来分析问题，关键是多查，多尝试，关键结点设置快照，防止爆炸。</p><p>在这里使用云服务器配置完全分布式环境！！！</p><a id="more"></a><!-- toc --><ul><li><a href="#配置环境">配置环境</a></li><li><a href="#准备工作">准备工作</a><ul><li><a href="#软件准备">软件准备</a></li><li><a href="#服务器准备">服务器准备</a><ul><li><a href="#服务器hosts文件修改">服务器hosts文件修改</a></li><li><a href="#ssh免密登录配置">ssh免密登录配置</a></li><li><a href="#服务器环境变量配置">服务器环境变量配置</a></li></ul></li></ul></li><li><a href="#软件配置">软件配置</a><ul><li><a href="#zookeeper配置">Zookeeper配置</a></li><li><a href="#hadoop配置">Hadoop配置</a></li><li><a href="#hbase配置">Hbase配置</a></li></ul></li><li><a href="#问题汇总">问题汇总</a><ul><li><a href="#配置免密登录">配置免密登录</a><ul><li><a href="#执行ssh-copy-id-i-rootslave1时出现sh-sshauthorized_keys-permission-denied">执行ssh-copy-id -i root@slave1时出现sh: .ssh/authorized_keys: Permission denied</a></li><li><a href="#修改文件权限时报错提示chmod-changing-permissions-of-authorized_keys-operation-not-permitted">修改文件权限时报错提示：chmod: changing permissions of ‘authorized_keys’: Operation not permitted</a></li><li><a href="#出现各种retrying或者ipcclient-retrying-connect-to-server-0000000010020">出现各种retrying，或者ipc.Client: Retrying connect to server: 0.0.0.0/0.0.0.0:10020.</a></li></ul></li><li><a href="#zookeeper配置问题">Zookeeper配置问题</a><ul><li><a href="#执行zkserversh-start之后再执行zkserversh报错error-contacting-service-it-is-probably-not-running">执行zkServer.sh start之后，再执行zkServer.sh报错Error contacting service. It is probably not running.</a></li></ul></li><li><a href="#hadoop配置问题">Hadoop配置问题</a><ul><li><a href="#执行hdfs-dfsadmin-report时报错call-to-master192168411349000-failed-on-connection-exception-javanetconnectexception">执行hdfs dfsadmin -report时报错Call to master/192.168.41.134:9000 failed on connection exception: java.net.ConnectException:</a></li><li><a href="#测试wordcount时出现运行任务卡在runnning-job的地方">测试wordcount时出现运行任务卡在runnning job的地方</a></li></ul></li></ul></li></ul><!-- tocstop --><p>首先上报自己的配置环境：</p><hr><h1><span id="配置环境">配置环境</span></h1><p>服务器：云服务器，腾讯云</p><p>操作系统：CentOS7</p><p>Java版本:1.8.0_221</p><p>Hadoop版本:3.1.2</p><p>Hbase版本:1.4.10</p><p>Zookeeper版本:3.4.14</p><hr><h1><span id="准备工作">准备工作</span></h1><p>首先做准备工作，准备两台云服务，进入服务商提供的云服务器的控制台，进入安全组，打开TCP:1-65565的所有端口，同时打开云服务器的快照设置，至少每两天拍一次快照。因为打开了所有的端口，非常容易被黑客进攻，当被黑客攻击时，一般服务商会通知你，那是再进入安全组，对那个进攻你的IP使用安全组提供的拒绝操作。</p><p>在这里推荐FinalShell的远程工具，可视化的文件管理，快捷切换多个服务器终端，显示服务器的cpu、内存占用率等功能，可以快速监测当前服务器状态。同时这个工具也提供了快捷的文件上传服务，简单的文本文档可以双击直接查看，比较方便。</p><h2><span id="软件准备">软件准备</span></h2><p>把下载好的linux版本的jdk等软件暂时直接塞到/root里面。</p><p>推荐在华为镜像站中下载，版本比较全面。</p><p>首先下载jdk1.8，按照道理来说jdk1.8的各个版本应该都可以，下载后直接解压在/usr/local文件夹下即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf jdk-8u221-linux-x64.tar.gz</span><br><span class="line"><span class="comment">#此时解压出来的应该是jdk1.8.0_221</span></span><br><span class="line">mv jdk1.8.0_221 /usr/<span class="built_in">local</span></span><br><span class="line"><span class="comment">#移动jdk去目标文件夹</span></span><br></pre></td></tr></table></figure><p>到了这一步可以暂时放下，我们先不配置环境变量，进行下一步。</p><p>把下载好的Hadoop、Hbase、Zookeeper，按照上面的做法，也放到上述文件夹中。</p><p>这一步所有的服务器节点都要做。</p><h2><span id="服务器准备">服务器准备</span></h2><h3><span id="服务器hosts文件修改">服务器hosts文件修改</span></h3><p><strong>这一步非常非常重要！！也非常容易错！！</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一步，在任意路径下使用该命令</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment">#之后会显示本机的内网ip，另一种方法是去服务上提供的控制台，那里会提供内网和外网ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二步，使用下面这条命令查看服务器名称</span></span><br><span class="line">hostname</span><br><span class="line"><span class="comment">#一般不推荐使用给的默认名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第三步，更改当前服务器名称，主服务器就是master，从服务器就是slave1、slave2之类的</span></span><br><span class="line">hostnamectl <span class="built_in">set</span>-hostname master</span><br><span class="line"><span class="comment">#之后查看hostname是否更改成功</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment">#第四步，设置服务器hosts文件</span></span><br><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>打开hosts文件后，删除当前文件中的所有内容，在文件中写入以下内容</p><p>此处的master，slave1等，就是服务器名，而后面的则是填写服务器的ip地址。</p><p><strong>注意！！</strong></p><p><strong>这里的IP地址</strong></p><p><strong>对应本机的IP地址填写内网IP地址！！</strong></p><p>**对应其他服务器的IP地址填写外网ip地址！！</p><p><strong>千万注意，在保存退出编辑的时候，当前文件只有各个节点的配置信息，没有其他内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master ***.***.***.***</span><br><span class="line">slave1 ***.***.***.***</span><br></pre></td></tr></table></figure><p>然后对配置是否成功进行测试，我们拿master主机来进行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先对本机</span></span><br><span class="line">ssh master</span><br><span class="line"><span class="comment">#之后一般让你输入密码，根据提示输入密码后如果成功登入本机，则证明配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再对其他服务器测试</span></span><br><span class="line">ssh slave1</span><br><span class="line"></span><br><span class="line"><span class="comment">#.....其他若干一一测试</span></span><br></pre></td></tr></table></figure><p>登入其他服务器后，使用logout命令即可退出ssh登录。</p><p><strong>这项配置，需要在所有的节点服务器中操作</strong></p><h3><span id="ssh免密登录配置">ssh免密登录配置</span></h3><p>这一步同样非常重要，也是问题频繁出现的地方！！！</p><p>最先的最先，关闭防火墙，一般的腾讯云服务器没有打开防火墙。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先进入/root目录。</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成ssh密钥</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment">#分发公钥，将密钥发送至其他服务器</span></span><br><span class="line">ssh-copy-id -i root@master</span><br><span class="line">ssh-copy-id -i root@slave1</span><br><span class="line"><span class="comment">#...，直到所有的服务器都被分发完成，注意，自己也要给自己分发公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来验证是否完成免密登录</span></span><br><span class="line">ssh master</span><br><span class="line"><span class="comment">#如果不需要密码直接就可以登录到服务器中，则证明配置成功</span></span><br><span class="line"><span class="comment">#...，依次对所有的节点进行测试。</span></span><br></pre></td></tr></table></figure><h3><span id="服务器环境变量配置">服务器环境变量配置</span></h3><p>接下来配置服务器的环境变量，免得测试的时候到处切换文件夹。</p><p>打开以下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>打开后在文件的最后最后，加上以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/jdk</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">export PATH=.:$JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME=/usr/local/hadoop-3.1.2</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_HOME=/usr/local/zookeeper-3.4.14</span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_HOME/bin</span><br><span class="line"></span><br><span class="line">export HBASE_HOME=/usr/local/hbase-1.4.10</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$HBASE_HOME/bin</span><br></pre></td></tr></table></figure><p>或者根据自己的文件配置路径，更改各项的HOME路径。</p><p>之后保存退出，在命令行中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>用此命令更新环境变量。</p><p>接下来测试各项配置是否正确.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#测试Java</span></span><br><span class="line">java -version</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试Hbase</span></span><br><span class="line">hbase version</span><br></pre></td></tr></table></figure><p>其他的各项测试之后再测。</p><h1><span id="软件配置">软件配置</span></h1><p>尽量从简单到难去配置，除了一些依赖关系的。</p><h2><span id="zookeeper配置">Zookeeper配置</span></h2><p>首先配置最简单的Zookeeper，进入Zookeeper的存放路径，如果和我配置的一样，则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入文件夹</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/zookeeper-3.4.14</span><br><span class="line"><span class="built_in">cd</span> conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#将提供的样例配置文件转化到我们的配置文件上</span></span><br><span class="line">mv zoo_sample.cfg zoo.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后对配置文件进行修改</span></span><br><span class="line">vim zoo.cfg</span><br></pre></td></tr></table></figure><p>打开配置文件后，对以下内容进行修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#数据文件目录</span><br><span class="line">dataDir=/usr/local/zookeeper-3.4.14/tmp/data</span><br><span class="line">#日志目录</span><br><span class="line">dataLogDir=/usr/local/zookeeper-3.4.14/logs</span><br></pre></td></tr></table></figure></p><p>在文件的最后添加以下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.1=master:2888:3888</span><br><span class="line">server.2=slave1:2888:3888</span><br><span class="line">#######↑这一位叫服务器号，只能时数字，且0-255</span><br><span class="line">#有几个节点服务器添加几个</span><br></pre></td></tr></table></figure></p><p>然后再创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/zookeeper-3.4.14</span><br><span class="line">mkdir logs</span><br><span class="line">mkdir tmp</span><br><span class="line"><span class="built_in">cd</span> tmp</span><br><span class="line">mkdir data</span><br><span class="line">vim myid</span><br><span class="line"><span class="comment">#在文件中写前面配置的服务器号，这是哪台服务器就写几，这个文件只写一个数字</span></span><br></pre></td></tr></table></figure><p><strong>以上所有操作需要在各个服务器节点执行。</strong></p><p>接下来直接在所有的节点服务器执行以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start</span><br></pre></td></tr></table></figure></p><p>之后在在任意节点使用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh status</span><br></pre></td></tr></table></figure></p><p>启动成功后：</p><p><img src="/img/zookeeper.jpg" alt="启动成功后显示status"></p><p>如果显示为leader或者follower，则启动成功。也可以使用jps查看是否有QuorumPeerMain进程。</p><p>写一些常用的zookeeper指令：</p><p>zkServer.sh start(启动)。</p><p>zkServer.sh restart(重启)</p><p>zkServer.sh status(查看状态)</p><p>zkServer.sh stop(关闭)</p><h2><span id="hadoop配置">Hadoop配置</span></h2><p>噩梦配置来了，我先贴出来什么文件需要修改，在分别贴出这些文件需要修改什么：</p><p>需要修改的文件有这些：</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/core-site.xml</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/hdfs-site.xml</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/mapred-site.xml</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/yarn-site.xml</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/hadoop-env.sh</p><p>/usr/local/hadoop-3.1.2/etc/hadoop/workers</p><p>/usr/local/hadoop-3.1.2/sbin/start-yarn.sh</p><p>/usr/local/hadoop-3.1.2/sbin/start-dfs.sh</p><p>一个一个贴出内容：</p><p><strong>core-site.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-3.1.2/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode上数据块的物理存储位置<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>hdfs-site.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-3.1.2/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-3.1.2/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.secondary.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>mapred-site.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>yarn-site.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8080<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:8082<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services.mapreduce.shuffle.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>httpshuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>604800<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>40.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改或者在hadoop-env.sh中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_221</span><br></pre></td></tr></table></figure><p>在start-yarn.sh最上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure></p><p>在start-dfs.sh最上面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=hdfs</span><br><span class="line">HDFS_NAMENODE_USER=root</span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure></p><p><strong>以上所有的步骤必须在所有的服务器节点上进行！！！</strong></p><p>按照道理来说到这里应该可以了。</p><p>然后进行初始化测试！！</p><p>首先在任意目录下运行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#该指令用于初始化namenode</span></span><br><span class="line">hdfs namenode -format</span><br><span class="line"></span><br><span class="line"><span class="comment">#该指令用于启动所有的hadoop服务</span></span><br><span class="line">start-all.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#该指令用于查看各节点数据情况</span></span><br><span class="line">hdfs dfsadmin -report</span><br></pre></td></tr></table></figure><p>正常结果如图</p><p><img src="/img/report.jpg" alt="hadoop启动成功"></p><p>使用jps查看启动情况</p><p><img src="/img/hadoop_ready.jpg" alt="jps启动情况"></p><p>如果正常可以使用hadoop自带的wordcount工具来统计测试以下词语计数功能。</p><h2><span id="hbase配置">Hbase配置</span></h2><p>首先进入Hbase的根目录。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/hbase-1.4.10</span><br></pre></td></tr></table></figure></p><p>我们需要修改的文件也先列出来：</p><p>/usr/local/hbase-1.4.10/conf/hbase-site.xml</p><p>/usr/local/hbase-1.4.10/conf/hbase-env.sh</p><p>/usr/local/hbase-1.4.10/conf/regionservers</p><p><strong>hbase-site.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- hbase存放数据目录 --&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/opt/hbase/hbase_db<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"></span><br><span class="line">　　　　　　　　　　<span class="comment">&lt;!-- 端口要和Hadoop的fs.defaultFS端口一致--&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- 是否分布式部署 --&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- list of  zookooper --&gt;</span></span><br><span class="line">　　　　　　　　<span class="tag">&lt;<span class="name">value</span>&gt;</span>master:2181,slave1:2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">　　　　　　<span class="tag">&lt;/<span class="name">property</span>&gt;</span> 　　　</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后修改<strong>hbse-env.sh</strong>中的代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入Java路径</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.8.0_221</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入hadoop路径</span></span><br><span class="line"><span class="built_in">export</span> HBASE_CLASSPATH=/usr/<span class="built_in">local</span>/hadoop3.1.2/etc/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment">#不使用Hbase自带的zookeeper，如果没有安装zookeeper，请写成ture</span></span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>最后在<strong>regionservers</strong>文件中添加你的服务器节点的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br></pre></td></tr></table></figure></p><p><strong>以上所有步骤必须在所有的服务器节点上进行！！</strong></p><p>然后在master服务器上运行指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#必须在hadoop已经开启的状态下！！！</span></span><br><span class="line">start-hbase.sh</span><br></pre></td></tr></table></figure></p><p>然后再各个节点使用jps命令，检查是否有HRegionServer和HMaster进程。</p><p>如果有，尝试启动shell版的hbase：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase shell</span><br></pre></td></tr></table></figure></p><p>启动成功后如图：</p><p><img src="/img/hbase.jpg" alt="进入shell"></p><p>也可以访问网址，来在浏览器上可视化的查看hbase的管理：</p><p>master:16010/master-status</p><p>master是你master服务器节点的IP。</p><h1><span id="问题汇总">问题汇总</span></h1><h2><span id="配置免密登录">配置免密登录</span></h2><p>需要注意的是，配置免密登陆时的ssh的各种文件需要合适的权限才能正常工作。如果遇到如下情况：</p><h3><span id="执行ssh-copy-id-i-rootslave1时出现sh-sshauthorized_keys-permission-denied">执行ssh-copy-id -i root@slave1时出现sh: .ssh/authorized_keys: Permission denied</span></h3><p>这种情况常常是因为文件权限出了问题，需要修改文件的权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入.ssh的上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改.ssh文件夹的权限为700</span></span><br><span class="line">chmod 700 .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入.ssh文件夹</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改authorized_keys文件的权限为644</span></span><br><span class="line">chmod 644 authorized_keys</span><br></pre></td></tr></table></figure></p><h3><span id="修改文件权限时报错提示chmod-changing-permissions-of-authorized_keys-operation-not-permitted">修改文件权限时报错提示：chmod: changing permissions of ‘authorized_keys’: Operation not permitted</span></h3><p>注意，如果这时候修改权限还有问题，证明你很有可能被黑客入侵过了，这时可能会报错，证明黑客将你的文件读写权限锁住了，不要怕，接着操作！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入ssh管理文件夹</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>然后我们了解出了chmod以外，还有一套能控制文件读写的操作：</p><p>lsattr，用于查看文件当前的可读写性<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsattr authorized_keys</span><br></pre></td></tr></table></figure></p><p>之后会显示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-----i-------e-- authorized_keys</span><br></pre></td></tr></table></figure></p><p>这里就证明，文件被i这个属性锁住了，我们接下来移除他。<br>使用chattr这个指令移除文件读写属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果有多个属性，比如说----ia------e--，下面的-i就替换成-ia</span></span><br><span class="line">chattr -i authorized_keys</span><br></pre></td></tr></table></figure><p>然后再执行chmod操作就可以了，注意，如果被黑客入侵，记得检查authorized_keys文件，如果有其他不认识的服务器名称，将authorized_keys的读写先改为777，然后删除不认识的服务器密钥信息，再改回644.</p><h3><span id="出现各种retrying或者ipcclient-retrying-connect-to-server-0000000010020">出现各种retrying，或者ipc.Client: Retrying connect to server: 0.0.0.0/0.0.0.0:10020.</span></h3><p>这样的问题大概概率时端口没看，或者ssh免密登录每配置好，首先检查服务商的安全组配置端口是否打开，然后再检查是否可以通过ssh免密登录各个节点。</p><h2><span id="zookeeper配置问题">Zookeeper配置问题</span></h2><h3><span id="执行zkserversh-start之后再执行zkserversh报错error-contacting-service-it-is-probably-not-running">执行zkServer.sh start之后，再执行zkServer.sh报错Error contacting service. It is probably not running.</span></h3><p>有几种可能性：</p><p>一、zookeeper要依赖的目录没有创建好，这是大概率</p><p>二、myid的配置没有配置对</p><p>三、检查修改的那个配置文件，是不是有打错或者中文符号的地方</p><h2><span id="hadoop配置问题">Hadoop配置问题</span></h2><h3><span id="执行hdfs-dfsadmin-report时报错call-to-master192168411349000-failed-on-connection-exception-javanetconnectexception">执行hdfs dfsadmin -report时报错Call to master/192.168.41.134:9000 failed on connection exception: java.net.ConnectException:</span></h3><p>这个问题出现时，先使用jps命令检查两台服务器是否启动了namenode和datanode，然后检查是否开启了防火墙，然后检查安全组端口是否打开，检查多台服务器的配置文件是否一直，最后检查ssh免密连接各台服务器是否有效，最后删除几台服务器下这个文件对应的两个目录：</p><p><strong>hdfs-site.xml</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--删除这个对应的目录--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-3.1.2/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--删除这个目录，ps：可以直接删除tmp目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop-3.1.2/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.secondary.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9870<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3><span id="测试wordcount时出现运行任务卡在runnning-job的地方">测试wordcount时出现运行任务卡在runnning job的地方</span></h3><p>可能是本机配置不够，hadoop认为你这个节点坏了，所以要下调这个阈值，在yarn-site.xml配置文件中修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.disk-health-checker.max-disk-utilization-per-disk-percentage<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里根据服务器配置来自己填写就好--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>40<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——内核编译</title>
      <link href="/2019/10/26/OS-1/"/>
      <url>/2019/10/26/OS-1/</url>
      
        <content type="html"><![CDATA[<h4><span id="安装一些工具">安装一些工具</span></h4><h4><span id="把新内核源码移动到usrsrc">把新内核源码移动到/usr/src</span></h4><h4><span id="suodo-make-clean">suodo make clean</span></h4><h4><span id="sudo-make-mrproper">sudo make mrproper</span></h4><h4><span id="sudo-make-distclean">sudo make distclean</span></h4><h4><span id="sudo-make-menuconfig">sudo make menuconfig</span></h4><h4><span id="sudo-make-j4-四线程加速">sudo make -j4 //四线程加速</span></h4><h4><span id="sudo-make-modules_install">sudo make modules_install</span></h4><h4><span id="sudo-make-install">sudo make install</span></h4><h4><span id="sudo-update-initramfs-c-k-你新内核的名字">sudo update-initramfs -c -k [你新内核的名字]</span></h4><h4><span id="sudo-update-grub">sudo update-grub</span></h4>]]></content>
      
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2019/10/17/mysql-3/"/>
      <url>/2019/10/17/mysql-3/</url>
      
        <content type="html"><![CDATA[<p>最近正好学到操作系统的线程和进程相关，学了PCB和TCB，正好数据库中也有相关知识，那就正好写一点数据库并发控制的东西。</p><a id="more"></a><h3><span id="并发控制">并发控制</span></h3><p>并发控制是什么呢。</p><p>ANS：并发控制就是当多个操作对同一个的数据（通常这样的数据被称作共享数据）进行操作，为了保证操作正常进行，且不会影响数据在操作后的正确性，我们要对访问共享数据的操作（线程，进程，用户访问）做访问控制。</p><p>数据的并发操作带来几种错误，分别是：</p><p><strong>1.丢失修改</strong></p><p>事务T1和T2同时读入数据并修改，后者破坏了前者提交的数据，就是丢失修改的情况。</p><p><strong>2.不可重复读</strong></p><p>不可重复是T1在读取数据后，T2执行更新操作，T1无法读到开始时读取的数据。</p><p><strong>3.脏读</strong></p><p>事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。</p><p><strong>3.幻读</strong></p><p>幻读实际上描述的是事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。</p><p>这里不具体讲这三种的具体情况和实例，在数据库操作时，我们常用不同的隔离等级来创建符合业务操作的表。封锁粒度影响了数据库库的并发性能。</p><h4><span id="隔离级别">隔离级别</span></h4><p>read uncommitted，read committed ， repeatable read，serializable。</p><p>四种分别对应解决丢失修改，不可重复读，脏读，幻读。</p><h3><span id="悲观锁和乐观锁">悲观锁和乐观锁</span></h3><p>为了控制并发，人们在业务逻辑的基础上建立起了两种理论逻辑，在这个理论逻辑上提出了悲观锁和乐观锁。锁机制的实现并非只在数据库中存在，在其他的程序设计（线程、进程中）同样存在。</p><p><strong>悲观锁</strong></p><p>悲观锁是认为基本上所有数据都有可能被并发访问，为了防止并发出错，我们提供S锁(共享锁)和X锁(排他锁)。使用锁机制，让数据在被操作时被隔离起来，从而避免并发出错。</p><p>悲观锁机制要求先上锁，再访问。</p><p>悲观锁的<strong>优点</strong>自然是数据不会出错，保证了安全性。</p><p>悲观锁的缺点也是很明显的，大量的加锁机制让操作变得复杂，同时锁机制的存在就会出现死锁的情况。</p><p>用c++实现一个锁机制；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> share_var = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">bool</span> share_lock_s = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> share_lock_x = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//创建读数据线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_read</span><span class="params">(<span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(share_lock_x)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"****x lock is existing****"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">5000</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//加共享锁</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"onlock s_lock"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">share_lock_s = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//复制数据到本地</span></span><br><span class="line"><span class="keyword">int</span> local = share_var;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"share_var is "</span>&lt;&lt;local&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放共享锁</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"release s_lock"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">share_lock_s = <span class="literal">false</span>;</span><br><span class="line">Sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建写数据线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_write</span><span class="params">(<span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(share_lock_s || share_lock_x)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"****some thread are using shared data****"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加共享锁</span></span><br><span class="line"><span class="keyword">if</span>(share_lock_s)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"////there is a s_lock////"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"onlock s_lock"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">share_lock_s = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//复制数据到本地</span></span><br><span class="line"><span class="keyword">int</span> local = share_var;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"share_var is "</span>&lt;&lt;local&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加排他锁</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"onlock x_lock"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">share_lock_x = <span class="literal">true</span>;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更改本地数据</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"rewriting shared_var"</span>;</span><br><span class="line">local -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将本地数据写回共享内存</span></span><br><span class="line">share_var = local;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">",result is "</span>&lt;&lt;local&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次释放所有锁</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"release all lock"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">share_lock_x = <span class="literal">false</span>;</span><br><span class="line">share_lock_s = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> tids[MAX];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"ready to create thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; MAX;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"create reading thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">ret = pthread_create(&amp;tids[i],<span class="literal">NULL</span>,say_read,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"create writing thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">ret = pthread_create(&amp;tids[i],<span class="literal">NULL</span>,say_write,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该锁机制遵循两端锁协议，所以仍有可能出现死锁。</p><p>但是如果使用一次封锁法，则事务串行话，不会产生死锁问题的出现。</p><p>虽然这里用c++的方式实现，但是数据库事务执行时也是相似的需要这些步骤。</p><p><strong>乐观锁</strong></p><p>乐观锁相对于悲观锁，认为数据并发修改的可能性不大，于是不借助数据库的锁机制实现，而是借助数据本身，冲突检测和数据更行。</p><p>CAS（Compare And Sawp）是典型的乐观锁技术。</p><p>通常乐观锁机制需要该数据本身版本号进行更新，比如说读取时该数据版本号为2，如果写回时该数据版本号仍然是2则写回数据，如果不是，则回滚事务，重新启动该事务。</p><h3><span id="乐观锁与悲观锁该如何选择呢">乐观锁与悲观锁该如何选择呢</span></h3><ol><li><p>乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p></li><li><p>悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p></li></ol><p>了解适用场景后，即可做出选择了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM解析（一）</title>
      <link href="/2019/10/07/jvm-1/"/>
      <url>/2019/10/07/jvm-1/</url>
      
        <content type="html"><![CDATA[<p>解析JVM总是一件非常难的问题，从头开始慢慢捋总是好的。<br><a id="more"></a></p><h4><span id="java程序的内存模型">Java程序的内存模型</span></h4><p>关于Java程序的内存模型，一定是被说烂了的，学过计算机组成之后就能在这里看到一些计算机组成的影子。</p><p>上来就上图，这张图传统而明显的展示出的Java的内存模型；</p><p><img src="/img/JVM.jpeg" alt="Java虚拟机运行时数据区"></p><p>其中方法区和堆(heap)是线程共享的，其余三个：虚拟机栈，本地方法栈，程序计数器是线程隔离的。</p><p>太明显了，所以直接总结和描述下几个区域的作用：</p><p><strong>一、程序计数器</strong></p><p>程序计数器简单来说，就是指向当前正在执行的程序字节码的标志，通过计数器来解决程序各种结构的正常运行。</p><p>Key:为什么程序计数器是线程隔离的？</p><p>Ans:因为Java的多线程是通过线程轮流切换且分配处理器时间实现的，所以对于每一条线程，该线程的程序计数器必须指向当前线程中程序正在执行的字节码，从而正确执行当前线程的指令。线程之间互不影响，所以程序计数器是线程私有的。</p><p><strong>二、Java虚拟机栈</strong></p><p>虚拟机栈我想用图的方式描述更加的形象具体：</p><p><img src="/img/VMS.jpeg" alt="虚拟机栈结构"></p><p>局部变量表中存放了基本数据类型、对象引用和returnAddress类型。</p><p>虚拟机栈的生命周期从线程创建到线程被销毁，同样虚拟机栈是线程私有的。</p><p>Key:为什么虚拟机栈是线程私有的？</p><p>Ans:每个线程中的方法互相独立，不会共享数据，所以它是线程私有的。</p><p><strong>三、本地方法栈</strong></p><p>本地方法栈和Java虚拟机栈相似，他们直接的区别是：</p><p>虚拟机栈用来执行的是Java方法，而本地方法栈用来执行Native方法。</p><p><strong>四、Java堆(Java heap)</strong></p><p>Java堆是Java虚拟机管理的内存占用最大的一块。这里也是垃圾收集器的主要管理区域，所以也被称做GC堆。</p><p>Java堆是被所有线程共享的一块内存区域，此处在虚拟机启动时被创建。</p><p>这个区域的唯一作用就是用来存放对象实例。</p><p>从内存回收的角度上讲，如今的收集器基本都是分代回收算法，所以Java堆中也可以被细分为<strong>新生代</strong>和<strong>老年代</strong>。</p><p>但不论如何细分，都和存放内容无关，无论什么区域，存储的都是对象实例。</p><p>Java堆可以是物理上不连续的，只要逻辑上连续就可以了。</p><p>当堆中没有足够的空间来完成实例分配，而且无法再扩展时，就会抛出OutOfMeoryError异常。</p><p><strong>五、方法区</strong></p><p>方法区则与Java堆相同，是线程共享的内存区域。</p><p>这里用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。</p><p>方法区也被称为Non-Heap。</p><p><strong>special:运行时常量池</strong></p><p>这里是方法区的一部分，各种编译时产生的字面值和符号引用被加载到运行时常量池中。</p><p>常量池同时具有动态性，运行期间也可以将新的常量放入常量池中，比如说String类中的intern()方法。</p><p>Key:intern()方法该怎么用？</p><p>Ans:在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。</p><p>这个用法十分奇特，有空可以将一下这个字符串对象和字符串引用的细节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自卑真的让人永远没有办法再站起来</title>
      <link href="/2019/10/06/2019-10-06/"/>
      <url>/2019/10/06/2019-10-06/</url>
      
        <content type="html"><![CDATA[<hr><p><strong>自卑真的让人永远再也站不起来。</strong></p><hr><p><img src="/img/timg11.jpg" alt="自闭"><br>&emsp;只有经历过自卑的人才知道，自卑是多么的恐惧，你看不到黑暗中的一束光，你也摸不到迷宫中的一面墙，你甚至感受不到时间的流逝。</p><p><strong>负能量预警！！！</strong></p><a id="more"></a><h5><span id="自卑让我成为最差的自己"><center>自卑让我成为最差的自己</center></span></h5><p>&emsp;这就是自卑，你只活在那片属于你自己的小小空间里，你出不去，摸不到别人，外面的人也看不到你，但是一点点风你就会被吹倒，轻轻的推搡别人就能让你摔的四仰八叉，你很痛，你很伤心，可是别人不在乎，不在乎你是不是挡了路，不在乎你是不是真的存在。他们的生活是光明快乐积极阳光的，自卑你只能生活在黑暗里，他们看不见你，但是随手就能给你留下一道深深的伤疤；你用力讨好别人，他们也不会在乎你是不是对他们有意义。</p><p>&emsp;这就是无情的自卑，脆弱无比，你的空间是一层薄薄的纸，一捅就破；自信的人，他们的空间是一堵铜墙铁壁，坚固无比。自卑的我总会多余的考虑那些铁壁一般的人的感受，可是他们不需要；自卑的我需要他人考虑我的感受，可是他们不会做。他们在乎的或许是宏图伟业，在乎的或许是自己路上追求的梦想。我在乎的是，我会不会被脆弱的自己击败。是的，自卑的人总是会被自己击败，自己的懦弱，自己的犹豫，自己小缺点，自己失误，最终构成了失败的人生，即使再别人看来可能是并不是，可是当你自卑的那一刻就永远失败了。</p><p>&emsp;别人对自卑者的评价是自卑者活下去最后的希望，外界给我好的评价我能越来越好的做下去，可是当别人只有一点点的不满，你就完了，你毁在了自己的手里。为了让他人给你好的评价，你要做的只有：舔。用力的舔，不论对错，不论是不是下贱，你只希望别人给你一点好脸看。卑微的像个路边的石头，这是个恶性循环，只要开始，就跳出去就难比登天，再也不能成为更好的自己。</p><p>&emsp;自卑者期待的是别人在乎他，在乎他的意见，在乎他的话语，在乎他的行为，在乎他的选择。可是谁会在乎自卑的人的这些，自信的人走的是自己的康庄大道；努力的人根本不在乎你是什么，他们自己在自己的路上走着。</p><p>&emsp;总让我想起来小矮星彼得，无论是他和James Potter还是伏地魔的时候，他都卑微的像条虫，就和他的阿尼马格斯一样，一只老鼠，多么有趣。</p><h5><span id="我醒不过来"><center>我醒不过来</center></span></h5><p>&emsp;我或许是一个自卑和努力都在的人，或许称不上努力吧。我总在自己的世界里努力着，我渴望得到别人的认可，我渴望证明自己的能力，我渴望别人在乎我的一切。但是自卑的恶魔在我耳边永远的低吟着，他说：你什么都做不到，没人在乎你，没人需要你。你比一颗尘埃还卑微，你什么都做不到；你毫无能力，没有英俊的面容，没有健壮的身躯，没有渊博的知识，不配拥有好的生活，不配拥有你渴望的一切；你是工具，你是棋子，你是尘埃，你什么都不是。</p><p>&emsp;我曾经也是一个没心没肺的人，曾经的我不知道什么是自信和自卑，我只过自己的快乐日子，失败了哭一哭，忘了就继续走；成功了就翘几天尾巴，之后还是原来的样子。魔鬼找上门的时候什么都没有改变，只是你忽然失去了快乐的能力，你的一切都是在为了讨好别人做的而已。失去了灵魂，失去了快乐，深深的躺在黑暗里，看着光离你越来越远，看着四周越来越黑，直到什么都看不到。</p><p>&emsp;我慌了，我在这片伸手不见五指的地方疯狂的奔跑，不管他对不对，是不是我想要的，我害怕，害怕失去心里最后的一团火。更努力的讨好别人，更在乎别人的感受，更用劲的思考别人的想法，失去自己观点，变得举棋不定，变得多疑，变得敏感。再也回不去阳光普照的地方了。或许有人还在那边努力的给我照亮看不见的路，短暂的照亮黑色的归途，但是恶性循环的我说不定早就无药可医了。</p><p>&emsp;现实生活里不存在像童话小说一般的和谐平等，外来的恶意，轻视，孤立，真的能让一个人从正常变得永世堕落。世人都不是圣人，傻乎乎的我还以为他们愿意听的痛苦，他们愿意带我走出黑暗，谎言总比真诚多，大部分的人都是为利来，为利往吧。达成目标后，再也没有人愿意继续带着累赘了，留下我在黑暗中呼唤那些熟悉的名字，可是空空的回音带来的只是绝望吧。心中的黑暗和夜里的黑暗相辅相成，成就了我一个个无法入眠，泪流不止的夜晚。</p><p>&emsp;渐渐的，我会失去勇气，失去信仰，失去奋斗，失去未来，失去一切，永远的沉沦在漆黑一片的失败炼狱里。</p><p>&emsp;或许有人真的能把我带出这片永世梦魇，给我一个香甜的好梦。</p><center><img src="/img/19-10-6-1.jpg" alt="我只是一个死胖子"></center><p><strong>愿这世间再柔软一点，再温暖一点，在善良一点，在光明一点，给自卑者一点活下去的希望。</strong></p><p><strong>愿这世间的自卑者再坚强一点，再勇敢一点，再努力一点，再成功一点，成就了自己，就能不要让自己再自卑下去了。</strong></p><p><strong>愿这世间善良的人再幸福一点，再美好一点，再幸运一点，愿你们的一生都被幸福快乐照耀。</strong></p><p><strong>愿这时间残酷的人在自己的路上永远不要摔倒，这样自卑者就不会成为你们的垫脚石了。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能MySQL（二）</title>
      <link href="/2019/09/25/mysql-2/"/>
      <url>/2019/09/25/mysql-2/</url>
      
        <content type="html"><![CDATA[<p>这次的的内容主要是如何优化特定类型的查询。<br><a id="more"></a></p><h4><span id="优化count查询">优化COUNT()查询</span></h4><p>&emsp;首先需要了解COUNT()的两个作用：</p><ol><li>统计某个列值的数量；</li><li>统计行数；</li></ol><p>&emsp;在统计列值时要求列值是非空的，比如说NULL就不会被计入COUNT()统计中，我们举个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(tel_num) <span class="keyword">FROM</span> information</span><br><span class="line"><span class="comment">#这条sql语句的作用是统计information表中已经提交了电话的人数</span></span><br></pre></td></tr></table></figure></p><p>&emsp;而在统计行数时，最常用的的就是使用通配符，以下举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> information</span><br><span class="line"><span class="comment">#这条语句的作用就是返回整张表的行数</span></span><br></pre></td></tr></table></figure><p>然后知道在MySQL中，COUNT()在使用没有任何条件的行数查询是非常快的；</p><p><strong>接下来讲怎么优化:</strong></p><p>首先在MySQL5.7中，并没有发现如下语句如书中说到的不使用索引的情况，比如以下语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> information <span class="keyword">where</span> main_id &lt; <span class="number">100579</span></span><br><span class="line"><span class="comment">#语句在5.7版本是默认使用主键的BTREE索引的，不存在需要优化的情况</span></span><br></pre></td></tr></table></figure></p><p>所以在了解书本中知识时，首先去实践是否真的存在这种情况，再去学习是否需要做更深的学习。</p><h4><span id="关联查询优化">关联查询优化</span></h4><ol><li>确保ON或者USING子句列上有索引。</li><li>确保GROUP BY和ORDER BY子句上至涉及到一个表中的列。</li></ol><h4><span id="limit分页优化">LIMIT分页优化</span></h4><p>我们说一个简单的优化方法，先来看一个简单的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information <span class="keyword">ORDER</span> <span class="keyword">BY</span> main_id <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">20</span></span><br></pre></td></tr></table></figure><p>这句话查询的是第100000之后的20个数据，我们使用EXPLAIN语句查询，就会发现这个语句会查询100020条数据，且其他的100000的数据都会被抛弃，这会让查询时间变得非常长。</p><p>所以得知，偏移量越大，DBMS的查询速度越慢。这里我们聊两种方法：</p><p>1.第一种，子查询法</p><p>使用子查询法来加快大数据量的分页方法，来写一个：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> information</span><br><span class="line"><span class="keyword">WHERE</span> main_id &gt;=</span><br><span class="line">  (<span class="keyword">SELECT</span> main_id <span class="keyword">FROM</span> information <span class="keyword">ORDER</span> <span class="keyword">BY</span> main_id <span class="keyword">LIMIT</span> <span class="number">100000</span>,<span class="number">1</span> )</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>通过定位先找到记录，然后再选择所需的数据。</p><p>2.第二种，标签定位法</p><p>通过上次查询的最后一个数据来查询下一页的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information <span class="keyword">WHERE</span> main_id &gt; <span class="number">100000</span> <span class="keyword">limit</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这个分页方法在于彻底抛弃OFFSET，抛弃了偏移量，就避免了偏移量过大而引起的查询速度变慢。</p><p>同样按照刚才的思路抛弃OFFSET，使用BETWEEN也可以再某种意义上实现分页，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information <span class="keyword">WHERE</span> main_id <span class="keyword">BETWEEN</span> <span class="number">100900</span> <span class="keyword">and</span> <span class="number">100910</span></span><br><span class="line"><span class="comment">#使用BETWEEN来实现分页功能</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能MySql（一）</title>
      <link href="/2019/09/20/mysql-1/"/>
      <url>/2019/09/20/mysql-1/</url>
      
        <content type="html"><![CDATA[<hr><p>直接切入重点，对首先对MySql的查询进行优化。<br><a id="more"></a></p><h4><span id="mysql查询性能优化">MySql查询性能优化</span></h4><p>首先了解MySql的查询为什么会慢：</p><p>最首要的原因当然是访问数据太多，IO的开销极大，除去极少一部分查询需要逐一筛查数据，大部分的查询语句都可以在优化后获得不错的性能。</p><p>通过下面两个步骤来分析为什么数据访问会比较慢：</p><p>1、确认程序是否在检索大量超过需要的数据。不仅是行，也包括列。</p><p>2、确认服务器层是否在分析大量超过需要的数据行。</p><hr><h4><span id="一避免请求太多不需要的数据">（一）避免请求太多不需要的数据</span></h4><p>首先避免查询出超过客户端需求的数据，最简单有效的方法是使用 limit。<br>比如<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> username <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">group_id</span>=<span class="number">1</span> <span class="keyword">limit</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>其次不要在多表关联时返回全部列，同样在正常查询时也不要返回全部列。避免这样的写法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> SOMETABLE WHERE...;</span><br><span class="line"><span class="comment">#或者是这样的</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE1.user <span class="keyword">INNER</span> <span class="keyword">JOIN</span> TABLE2.user WHERE...</span><br></pre></td></tr></table></figure></p><p>返回过多的数据将造成太多的IO开销，使得整体读写变慢，尤其是在访问后被提取的数据集比较大的时候，就会造成进程阻塞，慢sql的形成。</p><p>最后是防止相同数据的反复读取，这相当于是在做无用功，这时可以使用一些缓存工具存储这些数据，减少开销。</p><h4><span id="二-重构查询">（二） 重构查询</span></h4><p>在写sql语句的时候，常常会遇到到底是写多个sql语句好，还是写一个复杂查询好。面对这个问题，现代计算机硬件发展的已经很不错了，不用再在这种小问题上考虑太多。复杂查询常常要挑战思维难度，耗费时间，面对太复杂的sql语句，放心使用简单查询，这回大大减少你的工作量。但是一个查询就能完成的事，何必拆成多个呢。优先考虑减少工作量是否值得。</p><ul><li>切分查询</li></ul><p>&emsp;当发现一个查询的影响条数太多时，尝试使用多次查询的方式来减少压力，提高效率，使用limit来限制每次查询的条数，再在业务层使用循环，同时查询effected_row就可以了。</p><ul><li>分解关联查询<br>&emsp;其实这就很好理解了，将一个复杂查询拆分成多个小查询，看上去这样做有些愚蠢，但是如果使用好了缓存，就可以使得查询变得更高效。同时减少冗余记录，将数据库模块化，增加扩展性。</li></ul><h4><span id="三避开mysql的局限性">（三）避开MySql的局限性</span></h4><p>MySql可以帮助我们优化语句查询中的很多问题，但是同样存在局限性。这时候通过人工改写查询，使得MySql查询变得更高效。</p><ul><li>关联子查询</li></ul><p>MySql的关联子查询其实非常糟糕，如果使用过SQL Server的人在使用MySql的时候就会发现，MySql不能使用一些非常方便的子查询特性，繁杂的子查询也有些让人头疼。</p><p>首先使用EXPLAIN EXTENDED看看这条语句被改写成了什么，如果发现其中有使用变成了多表关联，如果使用到了多表关联，同时语句的外层是一个很大的表被关联，我们就可以用手动关联的方式来控制该条查询避免对外部大型表的全部扫描。</p><p>但是不要拒绝使用子查询，如果是一条非常影响性能的语句，首先将子查询方式和表关联方式的语句都写出来，对他们进行逐一测试，如果再选择性能最好的那一种方式。</p><ul><li>UNION的局限性</li></ul><p>在MySql中，Union的使用是有限制的，UNION外部条件无法优化到内部子句，所以需要在内部子句中也使用使用limit、group by、order by等子句。</p><ul><li>并行</li></ul><p>MySql不存在并行，别想了。</p><ul><li>最大值和最小值优化</li></ul><p>MySql的最大最小值优化没有你想象的那么美好，如果你在使用MIN(id)或者MAX(id)的同时，WHERE条件没有在id键上，那么就算是你在id上加了索引，DBMS依旧回做一次全表扫描。举一个书上的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(<span class="keyword">id</span>) <span class="keyword">FROM</span> test.actor <span class="keyword">WHERE</span> first_name = <span class="string">'zi'</span></span><br><span class="line"><span class="comment">#该语句就会将整个actor表进行扫描，即使是id上有索引，但是这个查询仍然要全表扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#来对这条语句进行一个优化，既然MySql的DBMS是从头到尾进行扫描，所以主键排序应该是从小到大扫描，手动对MIN(id)来优化</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> test.actor <span class="keyword">USE</span> <span class="keyword">INDEX</span>(PRIMARY)</span><br><span class="line">  <span class="keyword">WHERE</span> first_name = <span class="string">'zi'</span></span><br></pre></td></tr></table></figure><p>但是再实际操作中，发现在mysql5.7版本中，这种特殊的优化方式已经不再起作用了，主键最小值已经直接得到了优化。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记（一）</title>
      <link href="/2019/03/31/algorithm-1/"/>
      <url>/2019/03/31/algorithm-1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;我想把想要整理的算法分成数学算法，数据结构算法，排序算法，检索算法，和动态规划。贪心思想独划一类进行整理分析。</p><hr><a id="more"></a><h4><span id="算法分类依据">算法分类依据</span></h4><p>&emsp;首先称述一下分类的依据，在我现有知识水平认知下，数学算法通常是为了解决一类或者一种数学公式求解或者解决一部分数值计算问题，比如说<strong>解方程组，插值积分</strong>这一类的问题，<strong>素数判断，公因数等数学问题</strong>都被我划入这一类，从根本上来说，数学算法的根本就是将数学问题使用数学公式或者一类自然语言描述，在使用代码逻辑编写按顺序的计算方法，人类思维和计算机执行顺序不同，要将自然语言和数学思维转化成为算法代码的难度在很多问题中很高。数学算法的核心就是在于将数学公式抽象成为可以使用代码表达的表达式，进行有限次的运算求解，数学算法的成功与否同样在于算法复杂度，越低复杂度的算法越成功。</p><p>&emsp;数据结构算法则是对几种常用数据结构描述的基本操作，及在该数据结构上的一些高级操作，都被我划入数据结构算法中，数据结构算法的核心我认为是对最小结构单元和数据结构整体的分析，在于操作抽象数据类型时不同于传统数据类型的多种操作，无论是数组问题还是字符串问题同样属于数据结构的问题。基本数据结构<strong>线性表、栈、队列、数组、字符串、树、图、哈希表等</strong>大量的数据结构算法支撑起了更多基于他们的高级算法，理解核心的基础算法实现有助于高级算法的编写和高级算法中数据模型的抽象。</p><p>&emsp;排序算法检索算法作为基于数据结构的高级算法，其作用遍布所有的计算机系统和算法设计中，有序是检索效率提升的重要前提。有序的前提是能量的消耗，排序算法最重要的就是降低算法复杂度，在现今大量数据而现有资源不足的情况下，尽可能降低算法复杂度是计算机中最优美而富有成就的事，排序要吃透，彻彻底底的搞懂，从根上了解如何实现，以及基于多种数据结构的不同的排序和检索方式。</p><p>&emsp;DP和贪心是面试和现实问题中最需要的算法思想，这两种问题是建立在更多的数学思想和逻辑思想上的，这两部分的难度极大，我将会在前面的算法整理后，重点笔记记录。</p><hr><h4><span id="算法思想列表">算法思想列表</span></h4><h5><span id="emsp1-暴力穷举">&emsp;1、暴力穷举</span></h5><p>&emsp;暴力穷举是我们最最最常用的方法，我们拿最常见的素数搜索来举例：<br>素数的判断方法是，除了 1 和数字本身，没有任何一个因数，常见思路就是将该数字本身和 1 以外的与他们之间的所有数字和该数字取余数，如果该所有的余数不为0，即该数为质数。</p><p>&emsp;以下用java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span>  </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> n 输入一个整数</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@return</span> 返回该整数是否为素数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isP</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">2</span>;temp &lt; n;temp++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(n % temp == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> n 输入一个整数n</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@return</span> 返回从 2 到 n 的所有素数集合</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findPFrom2ToN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> incr = <span class="number">2</span>;incr &lt;= n ; incr++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isP(incr))&#123;</span><br><span class="line">        temp.add(incr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;可以发现该算法的复杂度是O(n<sup>2</sup>)，这是一个很恐怖的数量级。</p><p>&emsp;所以总结以下穷举法：</p><p>&emsp;1、穷举法的特点是列举出所有的可能性一一判断，选择合法可能性。</p><p>&emsp;2、穷举法思维难度低，易于实现，但常常具有效率极低，资源浪费极大的特点。</p><p>&emsp;3、穷举法适用于该问题的解是有限集，该方法无法用于连续系统的问题的求解。</p><hr><h4><span id="emsp2-递归与迭代法">&emsp;2、递归与迭代法</span></h4><p>&emsp;递归和迭代其实有一定的关联，在代码展示之前我们先对这两种方法做一点对比和分析</p><hr><p><table><br>  <th></th><br>  <th>分析</th><br>  <th>优点</th><br>  <th>缺点</th><br>  <tr><br>    <th>递归</th><br>    <td>通过函数自身调用自身而得到结果，要求最后函数结果收敛，调用时注意函数结果边界，不可出现无限调用的情况，函数结果发散则不可使用递归法。</td><br>    <td>1）代码量少，代码十分优雅，可读性极强。<br>2）无限集合也可使用递归的方式来获得收敛函数的结果，得到符合边界值的结果。</td><br>    <td>函数栈占用内存极大，在空间复杂度上不占任何优势，在OJ平台上极容易空间超限，在现实中极容易造成堆栈溢出。</td><br>  </tr><br>  <tr><br>    <th>迭代</th><br>    <td>迭代通过控制循环条件来使用，在同一函数中反复调用语句，常用计数器控制循环边界。</td><br>    <td>占用空间少，代码执行效率相比递归较高。</td><br>    <td>1）迭代代码繁杂，在大体量上程序阅读难度较大。<br>2）思维难度较大，常常需要手动调用栈结构来实现迭代方法，对于程序员来说提升了写代码的难度。</td><br>  </tr><br>  <tr><br>    <th>总结</th><br>    <td colspan="3">迭代和递归一般可以通过程序员的思维整合相互转化，从根本上来说应该都是循环的一种方式。</td><br>  </tr><br></table><br>&emsp;然后来使用代码实例来简单看一下这两种方法，我在这里使用树的前序遍历的递归和迭代方法来举例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*树节点对象封装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">  TreeNode left;</span><br><span class="line"></span><br><span class="line">  TreeNode right;</span><br><span class="line"></span><br><span class="line">  TreeNode(<span class="keyword">int</span> data)&#123;<span class="keyword">this</span>.val = data;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Traverse</span></span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *先序遍历入口函数，递归入口</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@param</span> root 树根节点</span></span><br><span class="line"><span class="comment">  *<span class="doctag">@return</span> 返回先序遍历结果集</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal_Recursion</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList() ;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        add(res,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *先序遍历递归函数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List temp,TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">        temp.add(root.val);</span><br><span class="line">        add(temp,root.left);</span><br><span class="line">        add(temp,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *借助栈来实现迭代式树的先序遍历</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preTraversal_Iteration</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        temp.add(node.val);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4><span id="emsp3-分治思想">&emsp;3、分治思想</span></h4><p>&emsp;分治分治，分而治之，分治思想常用于将一个大问题分割成为规模较小的子问题，且各个子问题和原问题的性质相同，求出子问题的解，原问题自然也就有了答案。</p><p>&emsp;经典的分治算法比如归并排序或者快排都是经典的分而治之。对于分治法而言，最重要的就是保证大问题分解出的子问题都是相同的，只不过是规模不同。</p><p>&emsp;比如在下述的归并排序中，就可以看到递归解决大问题，分解为小问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] number)</span></span>&#123;</span><br><span class="line">    mergeSort(number, <span class="number">0</span>, number.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] number,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将数组分为两部分，对左右两部分进行递归划分</span></span><br><span class="line">        mergeSort(number, left, mid);</span><br><span class="line">        mergeSort(number, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">//将两部分数组合并</span></span><br><span class="line">        merge(number, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把一个数组分为两部分，并对其进行有序化合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] number,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[number.length];</span><br><span class="line">    <span class="keyword">int</span> p1 = left;</span><br><span class="line">    <span class="keyword">int</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = left;</span><br><span class="line">    <span class="comment">//当两个数组都不为空时，将结果将小的元素添加到结果数组内</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(number[p1] &lt;= number[p2])&#123;</span><br><span class="line">            temp[p] = number[p1];</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[p] = number[p2];</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果1号数组仍有元素，则直接放入结果数组</span></span><br><span class="line">    <span class="keyword">while</span>(p1 &lt;= mid)&#123;</span><br><span class="line">        temp[p] = number[p1];</span><br><span class="line">        p++;</span><br><span class="line">        p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果2号数组仍有元素，则直接放入结果数组</span></span><br><span class="line">    <span class="keyword">while</span>(p2 &lt;= right)&#123;</span><br><span class="line">        temp[p] = number[p2];</span><br><span class="line">        p++;</span><br><span class="line">        p2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果数组内容回填</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> low = left;low &lt;= right;low++)&#123;</span><br><span class="line">        number[low] = temp[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="动态规划">动态规划</span></h4><p>动态规划的最大的特色是后一个状态和前一个状态相关，用于求解最大路径，最小和，最大和，最大长度的问题比较常用。</p><p>该种问题最常用的方式是推导出状态转移方程，只要将合理的状态转移方程编写出来，就可以解决大部分的问题。在写状态转移方程的时候要注意边界值的范围，通过确定合理边界值的范围就可以递推出动态数组的全部内容。</p><p>同样在此种问题中，并不是都需要使用O(N)的额外空间的，在有些优化问题中，可以抛弃掉前面已经不需要的状态，就可以在常数空间内解决动态规划问题，从而提高算法的空间利用效率。</p><p>还是举一个常用实例说明动态规划的解法。</p><h4><span id="打家劫舍leetcode198">打家劫舍,leetcode.198</span></h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><h5><span id="解题思路">解题思路</span></h5><p>这道题的解题思路其实比较简单，动态规划即可。</p><p>设dp[n]为在第n个房子处能偷到的最大的钱数，那么就有两种可能行，偷上家，和不偷上家。偷上家，那么这家就不能偷；不偷商家，那这家就能偷。这两种情况那种偷的多，就选择哪种。</p><p>首先边界条件，如果只有一个房子，那么dp[0] = nums[0];</p><p>如果有两个房子，那么dp[1] = Max(nums[0],nums[1]);</p><p>当n&gt;2时：</p><p>dp[n] = max(dp[n-1],dp[n-2] + nums[n]),即选择要不要偷上家。</p><h5><span id="代码实现">代码实现</span></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>] &gt; nums[<span class="number">0</span>]?nums[<span class="number">1</span>]:nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temp = <span class="number">2</span>;temp &lt; nums.length;temp++)&#123;</span><br><span class="line">        dp[temp] = Math.max(dp[temp - <span class="number">1</span>],dp[temp - <span class="number">2</span>]+nums[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot(Part.1)</title>
      <link href="/2019/03/18/springboot1/"/>
      <url>/2019/03/18/springboot1/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在使用框架后，我想来简单的写一些关于Springboot框架的内容，作为spring全家桶这些年来最火的框架，springboot有着框架中最为强大的一些功能，但框架本身和JavaWeb原生开发的知识断层仍然非常大，能跑通hellowolrd什么都代表不了，所以作为一个有着想给下一代使用框架的同志们的一些经验的梦想，我的建议是了解完一下内容后在来学习SpringBoot</p><a id="more"></a><p>&emsp;1)学会servlet</p><p>&emsp;2)了解JavaBean</p><p>&emsp;3)知道MVC的设计模式</p><p>&emsp;4)了解RESTful接口设计风格</p><p>&emsp;5)学会配置Maven依赖和插件使用</p><p>&emsp;6)Json数据类型</p><p>&emsp;7)元注解是什么，元注解该如何使用</p><p>&emsp;8)学会使用JDBC，学会使用mysql，知道sql语句的使用方式</p><p>&emsp;9)一颗敢于挑战知识断层和能坚持下去的心</p><hr><p>&emsp;好了让我们开始吧，对于我而言是在Springboot框架学习的时候第一次接触元注解，他强大的功能让我感到惊叹，可能是我自己能力不足，元注解的使用我认为对于初学者而言难度是偏大的，我们讲几个比较常用的元注解。一般来说，元注解可以放在类名上面，属性名上面，方法名上面，其注解功能各有不同，具体的操作我们具体再讲。</p><p>&emsp;我们来分析一下目录结构，.idea 目录是IDEA的项目配置文件，.mvn 是maven的包的位置，src 就是我们写源码的地方， 而 pom.xml 是用来配置maven依赖的地方，我假设大家是会用maven的。</p><p>&emsp;然后我们具体来看src的默认生成中包含了几个文件夹，main 和 test ，我们的源码就写在main中的Java里，另一个resources 是用来装载一些资源和Spring配置文件的。</p><p>&emsp;文件夹下默认生成了一个启动类，用来作为启动Springboot项目的启动类。其上生成了一个元注解。</p><p>&emsp;好了，我们已经看完了目录结构，我们来看看元注解，对于第一次接触框架的人，元注解大概是个难点，不好理解他的装载规则，那我们就来看看这个元注解，并且来分析其中几个比较常用的。</p><h4><span id="emsp1-sringbootapplication">&emsp;1) @SringBootApplication</span></h4><p>&emsp;该注解是生成Springboot应用就能看到的第一个注解，它是一个复合注解，包括了 @ComponentScan, @SpringBootConfiguration, @EnableAutoConfiguration 三个注解</p><p>&emsp;后两个注解都是与配置有关，第二个是标识本类为配置类，第三个则是启动默认Spring配置的含义</p><p>&emsp;而第一个比较重要，第一个的含义是将和该文件在相同目录下以及该目录里的所有子目录中被 @Component @Controller @Service @Repository 注解标识的类纳入Spring容器中管理。简单的来说就是你的文件能被加载到这个程序中而不是游离在程序之外。</p><p>&emsp; @SpringBootApplication 注解自动生成在项目的启动类里，在初始学习时不会影响。</p><p>&emsp;该注解一般被注解在类上面。</p><h4><span id="emsp2-restcontroller">&emsp;2) @RestController</span></h4><p>&emsp;本注解是除了1以外的另一个很重要的注解，看字面就能看出来他和MVC中的C也就是控制器有关，我们来分析一下，好像看不太懂，他可能是一个复合注解，Rest代表的是什么呢，其实是 @ResponseBody 的意思，其用来返回json类型的响应内容，其汉语含义是响应体，所以是用来处理响应内容的。而 @Controller 的用处是其中方法的return可以用来定向转跳到其他页面，在使用jsp和html转跳时可以使用被 @Controller 注解的控制器类中的方法，来定向返回到某个页面，而不能返回一个json结构化数据。</p><p>&emsp;一般 @RestController 用于前后端分离开发， @Controller 一看有jsp就是传统开发方式。</p><p>&emsp; @Controller 和 @RestController 一般注解在类上，该类使用作为控制器类被使用，用来使用其他的方法注解来快速配置路由。</p><h4><span id="emsp3-getmapping-postmapping-requestmapping">&emsp;3) @GetMapping @PostMapping @RequestMapping</span></h4><p>&emsp;这一段我会我会结合一些代码来让大家快速理解2中的注解和3中即将要将的注解，我们先来分析这三个注解。</p><p>&emsp;这三个注解都是用来处理路由关系的，GetMapping和PostMapping分别是来用于处理Get方法和Post方法的接口的，而RequestMapping可以通过注解中添加参数来控制Http方法，而且RequestMapping可以通过在类上注解，对请求路径进行同类中的细化，从而规范请求路径。</p><p>&emsp;那我们现在开始用一些代码来具体讲解我们前面讲述的内容吧。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/invitation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvitationController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *该方法将在使用Get方法时被调用，比如使用url方法访问 /invitation/love 时被调用，其在浏览器的响应中返回字符串 I love CyberSpace!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/love"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">invitationCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I love CyberSpace!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *该方法在使用Post方法时被调用，返回字符串I love to be a volunteer!</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/volunteer"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">codeTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"I love to be a volunteer!"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;本实例作为一个具体的控制器类的例子，大家应该是学会了如何正确编写一个控制器类吧，这就是开始使用SpringBoot开发Java项目的第一步！下次我希望讲解如何使用SpringBoot配置文件和编写yml文件，以及配置数据库方面的信息！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假计划</title>
      <link href="/2019/01/21/manange/"/>
      <url>/2019/01/21/manange/</url>
      
        <content type="html"><![CDATA[<h2><span id="寒假计划"><center>寒假计划</center></span></h2><p>&emsp;寒假计划，今天做一个寒假计划，为了防止寒假翻车，要好好学习，不能让我的寒假继续翻车，恨死我的大二上，魔鬼一般的上学期，惨绝人寰。总结一下自己的过去，以后再也不要挂科，学会自己的安排，对自己要下狠手，从今天起绝对不能，绝对不能让自己再后悔。<br><a id="more"></a></p><h4><span id="emsp第一安排自己每天的生活">&emsp;第一，安排自己每天的生活：</span></h4><p>&emsp;每天自己的概率论和电路学习时间保证在3个小时以上，电路总结必须完整，从各种电路图到公式。概率论保证每章的题都写完，每章的总结必须完整，根据复习手册的内容重新总结，保证自己的学习质量。目标就是一定要通过补考，没有任何质疑，只有必须通过这一条路。</p><h4><span id="emsp第二技术学习">&emsp;第二，技术学习：</span></h4><p>&emsp;保证技术学习每天在两小时以上，学习必须要专注，不能不够专注，保证技术摄入在开学之前可以使用框架进行快速开发。</p><h4><span id="emsp第三项目开发">&emsp;第三，项目开发:</span></h4><p>&emsp;保证项目开发进度在开学前处于基本完成状态，其主体功能已经完成，管理员流程完善，处于待测试状态。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端博客实例</title>
      <link href="/2018/10/01/20181001/"/>
      <url>/2018/10/01/20181001/</url>
      
        <content type="html"><![CDATA[<p>总算是在十一之前忙完了博客对接……总结一下问题，以后自己不要忘掉了。</p><hr><p>###1、JSONObject()的使用</p><p>这个东西比较麻烦，首先得在IDEA的File-&gt;project structure-&gt;modules里引用jar包，然后将jar包拷贝到Tomcat目录下lib中。</p><p>这里更新一下，不能使用的根本原因是没有使用正确的方法导入lib文件</p><p>使用时将lib文件夹放入web文件夹中</p><p>使用中文时需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建JSON数据对象</span></span><br><span class="line">JSONObject object = <span class="keyword">new</span> JSONObject();</span><br><span class="line">String test = <span class="string">"test"</span>;</span><br><span class="line"><span class="comment">//将数据放入json字符串中</span></span><br><span class="line">Object.put(<span class="string">"test"</span>,test);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//防止中文乱码</span></span><br><span class="line">resp.setContentType(<span class="string">"application/json;charset=utf8"</span>);</span><br><span class="line">resp.setCharacterEncoding(<span class="string">"utf8"</span>);</span><br><span class="line"><span class="comment">//返回json数据</span></span><br><span class="line">resp.PrintWriter().write(object.toString());</span><br></pre></td></tr></table></figure><p>###2、与vue脚手架等其他的后端跨域处理方式</p><p>对于后端来讲，只用setHeader就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resp.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>,<span class="string">"*"</span>);</span><br><span class="line"><span class="comment">/*设置允许跨域的端口*/</span></span><br><span class="line">resp.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"*"</span>);</span><br><span class="line"><span class="comment">/* 重新预检验跨域的缓存时间 (s) */</span></span><br><span class="line">resp.setHeader(<span class="string">"Access-Control-Max-Age"</span>, <span class="string">"3600"</span>);</span><br><span class="line"><span class="comment">/* 允许跨域的请求头 */</span></span><br><span class="line">resp.setHeader(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"*"</span>);</span><br><span class="line"><span class="comment">/* 是否携带cookie */</span></span><br><span class="line">resp.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure></p><hr><p>以上部分都可以放置在filter中，在servlet之前被执行。起到减少代码复用的作用，<br>在filter的结束时要链式执行filter，在web.xml中进行配置，在前的先被执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet（二）</title>
      <link href="/2018/09/16/Servlet22/"/>
      <url>/2018/09/16/Servlet22/</url>
      
        <content type="html"><![CDATA[<p><strong>cookie和session</strong><br>session是在服务器端记录信息用来确定用户身份。<br>cookie是在浏览器（客户端）本地记录用户信息来确定用户身份。<br>这两种技术都是用来绘画跟踪来弥补http协议无连接问题的。</p><a id="more"></a><p><strong>servlet中JDBC的使用</strong><br>各种Java框架的本质大多都是Servlet和JDBC的功能扩展，函数封装，理解了servlet和JDBC的联合使用，就能简单了解Java框架的实现方式。</p><p>需要实现控制层，服务层，数据访问层，模型层。</p><p>首先创建数据访问层。<br>先封装JDBC<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URL = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Sting PASSWORD = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Connection conn  = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">      System.out.println(<span class="string">"驱动加载失败"</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        conn = DriveManage.getConnection(URL,USER,PASSWORD);</span><br><span class="line">      &#125;<span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"数据库连接失败"</span>+e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Servlet(一)</title>
      <link href="/2018/09/13/Servlet/"/>
      <url>/2018/09/13/Servlet/</url>
      
        <content type="html"><![CDATA[<p>从今天开始学习servlet，servlet可以访问Java的所有api。</p><hr><p>Servlet是运行在服务器端的程序，运行在服务器端，HTTP服务和数据库之间进行操作。<br><strong>一、创建Servlet有两种常用方式：</strong><br><strong>1）通过继承HttpServlet类来实现Servlet的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      PrintWriter out = resp.getWriter();</span><br><span class="line">      out.println(<span class="string">"&lt;h1&gt;Hello Servlet个鬼啊&lt;/h2&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">      doGet(req,resp);      <span class="comment">//把doPost方法与doGet方法同化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>2）通过实现Servlet接口创建Servlet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ttt</span> <span class="keyword">implements</span> <span class="title">Servlet</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;       <span class="comment">//一次性初始化，后续请求时不再调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;    </span><br><span class="line">        <span class="comment">//执行任务的主要方法，用来处理客户端的请求，在适当的时候调用doGet(),doPost()等方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在servlet生命结束时调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>servlet是有生命周期的，有4个部分：构造器，init()方法，service()方法，destroy()方法，他们在一个周期内依次执行。</p><p>在web.xml文件中需要配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>该servlet类相对与src存放的位置<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Servlet</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/yoururlname<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servler-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>要注意前后关系必须是如此，可以配置多个servlet实例</p><p><strong>二、get和post提交的区别</strong></p><p>get和post是http协议中两种发送请求的方法</p><p><strong>1)get方法</strong><br>get请求会被放置在在url中，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.php?name=test&amp;password=123</span><br></pre></td></tr></table></figure><p>get请求可以被缓存，且有一定的长度限制（url有长度限制），且只能使用ASCII编码。</p><p>数据在url中可见，所以是不安全的传输方法，在敏感信息传递时不可以使用get方法。</p><p><strong>2）post方法</strong></p><p>post方法存于http请求之中，数据不可视，不受编码，数据长度限制</p><p><strong>三、doGet()和doPost()方法的使用</strong></p><p>doGet()方法和doPost()方法分别用来执行用get和post方法发来的数据。</p><p>这两种方法只用写一个，剩下的一种方法执行另种方法的相同逻辑即可。</p><p><strong>四、HttpServletRequest和HttpServletResponse</strong></p><p>是两种用来操作http请求的对象。</p><p><strong>Request中用来操作http请求中的各类参数，得到各类数据</strong></p><p>常用其中方法来获取方法中的参数及其参数名。</p><p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//设置服务器端编码为UTF-8编码</span></span><br><span class="line">    req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取id为username的参数</span></span><br><span class="line">    String username = res.getParameter(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取多个值为一个数组使用getParmeterValues()方法</span></span><br><span class="line">    String[] department = res.getParameterValues(<span class="string">"department"</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用getParmeterNames方法接收表单参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有参数名</span></span><br><span class="line">    Enumeration&lt;String&gt; paraNames = req.getParmeterNames();</span><br><span class="line">    <span class="keyword">while</span>(paramNames.hasMoreElement())&#123;</span><br><span class="line">      <span class="comment">//得到参数名</span></span><br><span class="line">      String name = paraNames.nextElement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//得到该参数的值</span></span><br><span class="line">      String value = req.getParameter(name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意在接受时，必须设置字符编码与客户端一致，否则出现乱码现象。<br>且get方法由于在url中无法传递中文，最好使用post方法传递中文参数，或者使用编码转换函数转换编码为utf8格式。</p><p><strong>Response为为了响应http的对象。</strong></p><p>其中的方法分为几类<br>1）向客户端发送数据的方法：<br>如getWriter()方法</p><p>2）向客户端发送响应头的方法<br>如setHeader()等方法；</p><p>3）向客户端发送响应状态码的方法<br>如setStatus().</p><p>常用向客户端输出数据的方法：<br>OutputStream流向客户端输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String value = <span class="string">"Hello Servlet"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从流中得到数据</span></span><br><span class="line">    OutputStream outputStream = resp.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应字符为UTF8格式，防止出现乱码</span></span><br><span class="line">    resp.setHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符转换为字节数组，用制定的UTF8编码</span></span><br><span class="line">    <span class="keyword">byte</span>[] dataByteArr = value.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用OutputStream向客户端输出字节数组</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用PrintWriter输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req,HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">    <span class="comment">//设置字符为UTF-8</span></span><br><span class="line">    String value = <span class="string">"Hello Servlet"</span>;</span><br><span class="line">    resp.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取PrintWriter输出流</span></span><br><span class="line">    PrintWriter out = resp.getWriter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置响应头,此处也可使用&lt;meta&gt;标签控制客户端</span></span><br><span class="line">    resp.setHeader(<span class="string">"content-type"</span>,<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出字符</span></span><br><span class="line">    out.write(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>五、servlet和jsp的区别</strong><br>jsp是servlet的简化版本，所有的jsp代码都会被编译成servlet，jsp是mvc中的v，而servlet是mvc中的c。<br>servlet是动态输出html内容，而jsp是静态html中嵌入java代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写写乱七八糟的</title>
      <link href="/2018/04/12/i-love-you/"/>
      <url>/2018/04/12/i-love-you/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/dragon.jpg" alt="“神龙实现我的愿望吧！”"></p><hr><p>神龙实现我的愿望吧！！！</p><p>好像一直想要什么东西来实现愿望……</p><hr><p>头号玩家好看，清明节看的今天回味还是很好看呢。</p><p>回忆杀，情怀杀，老玩家确实很有感触，说是美国票房一般，自己喜欢就好了，斯皮尔伯格的童心吧。</p><p>多读读书，想读人类简史，读完，想读丈量世界，看看高斯的世界。</p><p>还有好好学习最近没有好好学习。</p><p>没有好好学习的人不配实现愿望？</p><p>那我就要好好学习了。</p><hr><p>不就是好好学习么今天就继续。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018/4/7</title>
      <link href="/2018/04/07/2018-4-7/"/>
      <url>/2018/04/07/2018-4-7/</url>
      
        <content type="html"><![CDATA[<p>不知不觉已经过了好多个月了，在大学也生活了将近一年的，再过一段时间大概我也成为了学长吧</p><p>有时候还是不知道自己在做什么，是不是成为了自己想成为的人</p><p>清明就多出去走了几天，做了点想干的事情，去城市里面转一圈，远离这个小村子</p><p><img src="/img/IMG_P1.jpg" alt="校园落花"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test2</title>
      <link href="/2018/04/06/test2/"/>
      <url>/2018/04/06/test2/</url>
      
        <content type="html"><![CDATA[<p>人类啊，颤抖吧！！！！！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
